--- src/libdoxygen.pro.in	2012-04-14 14:53:02.000000000 +0200
+++ src/libdoxygen.pro.in	2012-06-02 17:39:20.000000000 +0200
@@ -99,6 +99,7 @@
 		perlmodgen.h \
 		lodepng.h \
 		pre.h \
+		preVerilog.h \
                 printdocvisitor.h \
                 pycode.h \
                 pyscanner.h \
@@ -165,6 +166,9 @@
 		types.h \
 		unistd.h \
 		util.h \
+		verilogscanner.h \
+		verilogdocgen.h \
+		verilogparser.hpp \
 		version.h \
 		vhdlcode.h \
 		vhdldocgen.h \
@@ -237,6 +241,7 @@
 		pagedef.cpp \
 		perlmodgen.cpp \
 		pre.cpp \
+		preVerilog.cpp \
 		pycode.cpp \
 		pyscanner.cpp \    
 		qhp.cpp \
@@ -254,6 +259,9 @@
 		translator.cpp \
 		util.cpp \
 		version.cpp \
+		verilogscanner.cpp \
+		verilogparser.cpp \
+		verilogdocgen.cpp \
 		vhdlcode.cpp \
 		vhdldocgen.cpp \
 		vhdlparser.cpp \
--- src/libdoxygen.t	2012-05-20 00:09:24.000000000 +0200
+++ src/libdoxygen.t	2012-06-02 17:33:12.000000000 +0200
@@ -107,6 +107,15 @@
 	$(YACC) -l -d -p vhdlScanYY vhdlparser.y -o vhdlparser.c 
 	-rm vhdlparser.c	
 	
+#$ GenerateDep("verilogscanner.cpp","verilogscanner.l");
+	$(LEX)  -8  -PverilogScanYY -t verilogscanner.l | $(INCBUFSIZE) >verilogscanner.cpp
+
+#$ GenerateDep("verilogparser.cpp","verilogparser.y");
+	$(YACC)  -v -d verilogparser.y -o verilogparser.cpp 
+
+#$ GenerateDep("preVerilog.cpp","preVerilog.l");
+	$(LEX) -PpreYYVerilog -t preVerilog.l | $(INCBUFSIZE) >preVerilog.cpp 
+	
 #$ GenerateDep("layout.cpp","layout_default.h");
 
 TO_C_CMD=sed -e "s/\\\\/\\\\\\\\/g" -e "s/\"/\\\\\"/g" -e "s/^/\"/g" -e "s/$$/\\\\n\"/g"
--- src/util.cpp	
+++ src/util.cpp	
@@ -6359,6 +6359,9 @@
   { "fortran",     "fortran", SrcLangExt_Fortran  },
   { "vhdl",        "vhdl",    SrcLangExt_VHDL     },
   { "dbusxml",     "dbusxml", SrcLangExt_XML      },
+    { "ucf",        "v",    SrcLangExt_VERILOG   },
+  { "qsf",        "v",    SrcLangExt_VERILOG   },
+  { "v",        "v",    SrcLangExt_VERILOG    },
   { "tcl",         "tcl",     SrcLangExt_Tcl      },
   { "md",          "md",      SrcLangExt_Markdown },
   { 0,             0,        (SrcLangExt)0        }
@@ -6430,7 +6433,9 @@
   updateLanguageMapping(".qsf",      "vhdl");
   updateLanguageMapping(".md",       "md");
   updateLanguageMapping(".markdown", "md");
-
+  updateLanguageMapping(".ucf",  "v");
+  updateLanguageMapping(".qsf",  "v");
+  updateLanguageMapping(".v",  "v");
   //updateLanguageMapping(".xml",   "dbusxml");
 }
 
@@ -7171,9 +7176,19 @@
     QFile f(fileName);
     if (f.open(IO_WriteOnly))
     {
-      ColoredImage img(data->width,data->height,data->content,data->alpha,
+      
+		if(data->icon==NULL)
+		{
+		ColoredImage img(data->width,data->height,data->content,data->alpha,
                        sat,hue,gamma);
-      img.save(fileName);
+           img.save(fileName);
+		}
+		else
+		{
+			ColoredImage img(data->width,data->height,0,data->alpha,
+				sat,hue,gamma,data->icon);
+			img.save(fileName);
+		}
     }
     else
     {
Index: src/doxygen_css.h
===================================================================
--- src/doxygen_css.h	(Revision 818)
+++ src/doxygen_css.h	(Arbeitskopie)
@@ -1130,4 +1130,9 @@
 "    display:inline;\n"
 "  }\n"
 "}\n"
-"\n"
+
+
+
+
+
+
Index: src/navtree_js.h
===================================================================
--- src/navtree_js.h	(Revision 818)
+++ src/navtree_js.h	(Arbeitskopie)
@@ -54,6 +54,7 @@
 "    node.expandToggle.href = \"javascript:void(0)\";\n"
 "    node.expandToggle.onclick = function() {\n"
 "      if (node.expanded) {\n"
+"       drawClassIcon(node) ;\n"
 "        $(node.getChildrenUL()).slideUp(\"fast\");\n"
 "        if (node.isLast) {\n"
 "          node.plus_img.src = node.relpath+\"ftv2plastnode.png\";\n"
@@ -219,8 +220,10 @@
 "        getNode(o, node);\n"
 "      } if (imm || ($.browser.msie && $.browser.version>8)) { \n"
 "        // somehow slideDown jumps to the start of tree for IE9 :-(\n"
+"        drawClassIcon(node); \n"
 "        $(node.getChildrenUL()).show();\n"
 "      } else {\n"
+"        drawClassIcon(node); \n"
 "        $(node.getChildrenUL()).slideDown(\"fast\");\n"
 "      }\n"
 "      if (node.isLast) {\n"
@@ -417,3 +420,47 @@
 "  $(window).load(showRoot);\n"
 "}\n"
 "\n"
+"function drawClassIcon(node) \n"
+" {   \n"
+"	  var zz=node.getChildrenUL();\n"
+" 	  var opp=node.childrenData[0][1];\n"
+" 	\n"
+"	  if(opp==null) \n" 
+"	  return;\n"
+"	  \n"
+"	  var cl=node.childrenData[0][1];\n"
+"	  if(cl.indexOf(\"All\")==0)\n"
+"	  return;\n"
+"	  \n"
+"	  \n"
+ "	for (var i = 0; i < zz.childNodes.length; i++)\n"
+ "	{\n"
+" 	var temp;\n"
+"	var cc=zz.childNodes[i].firstElementChild;\n"
+"	var len=cc.childNodes.length;\n"
+"     if(len<3) return;\n"
+"	\n"
+"	var b=node.childrenData[i].length;\n"
+"	if(b<4) return;\n"
+"	  temp=node.childrenData[i][3];\n"
+"	\n"
+"	var p=cc.childNodes[len-2];\n"
+"	\n"
+"	p.setAttribute(\"height\",\"16\");\n"
+"	if(temp.indexOf(\"4102\")>=0) p.setAttribute(\"src\",\"icon_parameter.png\");\n"
+"	if(temp.indexOf(\"4106\")>=0) p.setAttribute(\"src\",\"icon_port_in.png\");\n"
+"	if(temp.indexOf(\"4105\")>=0) p.setAttribute(\"src\",\"icon_port_out.png\");\n"
+"	if(temp.indexOf(\"4107\")>=0) p.setAttribute(\"src\",\"icon_port_inout.png\");\n"
+"	if(temp.indexOf(\"4097\")>=0) p.setAttribute(\"src\",\"icon_function.png\");\n"
+"	if(temp.indexOf(\"4104\")>=0) p.setAttribute(\"src\",\"icon_task.png\");\n"
+"	if(temp.indexOf(\"4113\")>=0) p.setAttribute(\"src\",\"icon_signal.png\");\n"
+"	if(temp.indexOf(\"4103\")>=0) p.setAttribute(\"src\",\"icon_process.png\");\n"
+"	if(temp.indexOf(\"4104\")>=0) p.setAttribute(\"src\",\"icon_task.png\");\n"
+"	if(temp.indexOf(\"4096\")>=0) p.setAttribute(\"src\",\"icon_function.png\");\n"
+"	if(temp.indexOf(\"4100\")>=0) p.setAttribute(\"src\",\"icon_comp_inst.png\");\n"
+"	if(temp.indexOf(\"4200\")>=0) p.setAttribute(\"src\",\"icon_wsignal.png\");\n"
+"	if(temp.indexOf(\"4201\")>=0) p.setAttribute(\"src\",\"icon_wire.png\");\n"
+"	if(temp.indexOf(\"4098\")>=0) p.setAttribute(\"src\",\"icon_final_decl.png\");\n"
+"	}\n"
+ "}\n"
+ "\n"
\ No newline at end of file
Index: src/definition.cpp
===================================================================
--- src/definition.cpp	(Revision 818)
+++ src/definition.cpp	(Arbeitskopie)
@@ -196,6 +196,15 @@
   return FALSE;
 }
 
+void Definition::addListType(QCString q)
+	{
+      qsl.append(q);
+	}
+
+QStringList& Definition::getList() {return qsl;}
+
+
+
 void Definition::addToMap(const char *name,Definition *d)
 {
   bool vhdlOpt = Config_getBool("OPTIMIZE_OUTPUT_VHDL");
@@ -996,7 +1005,7 @@
       if (definitionType()==TypeMember) thisMd = (MemberDef *)this;
 
       // vhdl  parser can' t start at an arbitrary point in the source code
-      if(this->getLanguage()==SrcLangExt_VHDL)
+      if(this->getLanguage()==SrcLangExt_VHDL || this->getLanguage()==SrcLangExt_VERILOG)
       {
         if (thisMd) VhdlDocGen::writeCodeFragment(ol,actualStart,codeFragment,thisMd);
         return;
Index: src/configoptions.cpp
===================================================================
--- src/configoptions.cpp	(Revision 818)
+++ src/configoptions.cpp	(Arbeitskopie)
@@ -336,6 +336,27 @@
                  FALSE
                 );
   //----
+   //----
+    cb = cfg->addBool(
+                  "OPTIMIZE_OUTPUT_VERILOG",
+                    "Set the OPTIMIZE_OUTPUT_VERILOG tag to YES if your project consists of Verilog \n"
+                    "sources. Doxygen will then generate output that is tailored for \n"
+					"Verilog. \n",
+                    FALSE
+                 );  
+
+	
+  //----
+
+	//----
+    cb = cfg->addBool(
+                  "HIDE_PORT",
+                    "Set the HIDE_PORT tag to YES Verilog ports are not shown  \n",
+                    TRUE
+                 );  
+
+	
+  //----
   cl = cfg->addList(
                  "EXTENSION_MAPPING",
                  "Doxygen selects the parser to use depending on the extension of the files it\n"
@@ -894,7 +915,7 @@
                  "blank the following patterns are tested:\n"
                  "*.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh\n"
                  "*.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py\n"
-                 "*.f90 *.f *.for *.vhd *.vhdl"
+                 "*.f90 *.f *.for *.v *.vhd *.vhdl"
                 );
   cl->addValue("*.c");
   cl->addValue("*.cc");
@@ -930,6 +951,7 @@
   cl->addValue("*.for");
   cl->addValue("*.vhd");
   cl->addValue("*.vhdl");
+   cl->addValue("*.v");
   //----
   cb = cfg->addBool(
                  "RECURSIVE",
Index: src/ftvhelp.cpp
===================================================================
--- src/ftvhelp.cpp	(Revision 818)
+++ src/ftvhelp.cpp	(Arbeitskopie)
@@ -34,7 +34,9 @@
 #include "pagedef.h"
 #include "docparser.h"
 #include "htmldocvisitor.h"
+#include "verilogdocgen.h"
 
+
 #define MAX_INDENT 1024
 
 
@@ -154,6 +156,28 @@
   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
 };
 
+
+static unsigned int vmodule_icon [16*16]=
+{
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,5551988,5551988,5486195,16777215,16777215,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,6010489,6207868,7061383,7258762,7651726,7651726,6864510,6142075,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,5944696,7127176,7849106,8505242,8636828,8702621,8505242,8373905,7651726,6142075,16777215,16777215,16777215,
+16777215,16777215,5223023,6863748,7914899,9358500,10212272,10802864,10802864,10278065,9358500,9227420,6995590,6076282,16777215,16777215,
+16777215,5157230,6273661,7849106,512,512,512,12707016,12772809,11919045,512,512,8505242,7586183,5944696,16777215,
+16777215,5223023,7586183,8439698,512,512,256,14216665,14479332,13429201,512,512,9227420,7192969,6076282,4435300,
+16777215,6010738,7586183,9227420,512,256,256,11911353,15332590,11911353,512,512,9424549,7783313,6076282,5091437,
+4303714,5944696,7651726,8702621,512,512,3423287,512,16186353,512,3423287,512,9358500,7783562,6273661,5157230,
+4501349,5944696,7061383,8571035,512,256,13429201,256,14479332,512,12838352,512,9293213,7717769,6076282,5091437,
+3582040,5223023,6863748,7783313,512,256,12182216,512,12969938,512,11919045,512,8505242,7061383,5944696,3713626,
+16777215,4632174,6010489,7651726,512,256,10802864,329990,461576,658699,9687722,512,7783313,6797955,5091437,3582040,
+16777215,4237921,5223023,6273661,512,512,9424549,9027484,512,8700570,8702621,512,6929541,5420402,4435300,16777215,
+16777215,16777215,3713378,4632936,6142075,7061383,7127176,7783313,7849106,7717519,7127176,6273661,5223023,4237921,3318868,16777215,
+16777215,16777215,16777215,3582040,4632174,5420402,5944696,6207868,6207868,6076282,6010738,5157230,3647833,3318868,16777215,16777215,
+16777215,16777215,16777215,16777215,3450454,4237921,4369507,5091437,5091437,4435300,4501349,3582040,2663253,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,2663253,2663253,2729046,3318868,3187539,2597459,16777215,16777215,16777215,16777215,16777215
+};
+
+
 static unsigned char folderclosed_a_png[528] =
 {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -442,6 +466,92 @@
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
 };
 
+static const char* icons_png[]=
+{
+"wire",
+"port_in",
+"port_inout",
+"port_out",
+"task",
+"function",
+"wsignal",
+"parameter",
+"comp_inst",
+"signal",
+"final_decl",
+"const_sig",
+"always",
+"process"
+};
+
+
+static unsigned int verilog_icons [16*16*14]=
+{
+16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7898800,5857398,7898800,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,12285256,16777215,16777215,12285256,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,15602670,16777215,16777215,15602670,15602670,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7898800,5857398,11779785,7898800,11730943,7898800,11779785,5857398,7898800,16777215,
+16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,16777215,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,16777215,16777215,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,16777215,16777215,16777215,16777215,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,15602670,16777215,15602670,16711935,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5857398,11730943,5337483,5857398,11730943,5857398,5337483,11730943,5857398,16777215,
+16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,12285256,16777215,16777215,12285256,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,12285256,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,15602670,16777215,15602670,16777215,15602670,16777215,15602670,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,3726815,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,3726815,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11779785,5337483,11138556,11138556,11138556,11138556,11138556,5337483,11779785,16777215,
+16777215,16777215,16777215,16777215,3726815,3726815,3726815,16777215,16777215,16777215,16777215,15602670,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13338717,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,16777215,16777215,11231540,11231540,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285256,16777215,16777215,16777215,11231540,11231540,16777215,16777215,16777215,12285256,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,3726815,16777215,16777215,15602670,16777215,16711935,16777215,15602670,16777215,16711935,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2661566,2661566,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,3726815,3726815,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7898800,7898800,5857398,10217976,9413806,5857398,9413806,10217976,5857398,7898800,7898800,
+16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13278334,13278334,13338717,16777215,16777215,16777215,16777215,12285256,16777215,16777215,12285256,16777215,16777215,16777215,16777215,16777215,16777215,11231540,13476744,13542279,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11231540,13476744,13542279,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,15602670,15602670,16777215,16777215,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,2661566,11596543,11596543,2661566,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,3726815,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5857398,9230834,9230834,13758714,5857398,15990015,5857398,9230834,9230834,9230834,5857398,
+16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13542536,13477001,13338717,36545,36545,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,29868,29868,11231540,13806997,13872789,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,29868,29868,11231540,13806997,13872789,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,15602670,16777215,16777215,16777215,15602670,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,2595003,9562879,9562879,9562879,9562623,2595259,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,3726815,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7898800,7898800,12435400,8173024,13818847,5857398,9413806,8243693,5857398,7898800,7898800,
+16777215,16777215,16777215,16777215,3726815,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13338717,13873048,13938585,13338717,11528956,11528956,36545,36545,16777215,16777215,16777215,16777215,16777215,16777215,30895,30895,9035771,9101307,11627069,14203044,14203300,11627069,11627067,16777215,16777215,16777215,16777215,16777215,16777215,16777215,30895,30895,9035771,9101307,11627069,14203044,14203300,11627069,11627067,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,2397112,10020607,8249087,8249087,8249087,8249087,10020607,2462647,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,3726815,15602670,3726815,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,3726815,3726815,3726815,16777215,16777215,3726815,16777215,16777215,3726815,3726815,3726815,3726815,3726815,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14804457,1089760,1089760,12969206,12969206,7322601,7322601,5337483,11779785,16777215,
+3726815,3726815,3726815,3726815,3726815,16777215,16777215,3726815,16777215,16777215,3726815,3726815,3726815,3726815,3726815,16777215,16777215,16777215,13338717,13338717,13338717,14334887,13280650,14269352,14334887,13338717,11069691,11069692,5287378,9232634,35518,16777215,16777215,32436,32437,32436,8182522,4696274,9757435,9757435,12285256,14467503,14467246,12555127,14334887,12285000,12285000,16777215,16777215,32436,32437,32436,8182522,4696274,9757435,9757435,12285256,14467503,14467246,12555127,14334887,12285000,12285000,12285000,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,3726815,3726815,3726815,16777215,16777215,3726815,16777215,16777215,3726815,3726815,3726815,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,2264498,9231358,7131134,7131134,7131134,7131134,9231358,2264499,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,3726815,3726815,3726815,15602670,15602670,3726815,15602670,15602670,3726815,3726815,3726815,3726815,3726815,15602670,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,12084480,12752998,13212508,13804112,14329152,12084480,1083608,697571,1089760,12966375,12435400,5337483,6664677,5857398,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12356718,12356718,12291182,14994880,14994880,14994880,14994880,12877908,14022397,14022397,6731730,11726331,2396597,16777215,16777215,8642043,8642043,2396597,11726331,6731730,14022397,14022397,12877908,14994880,14994880,14994880,14994880,12291182,12356718,16777215,16777215,8642043,8642043,2396597,11726331,6731730,14022397,14022397,12877908,14994880,14994880,14994880,14994880,12291182,12356718,12356718,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2131886,9887486,9887486,9887486,9887486,2066350,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,8144663,8144663,8144663,8144663,8144663,8144663,13693183,1083608,1089760,9685996,13225951,11779785,5857398,7898800,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12285000,12285000,12285000,14334887,12555127,14467246,14467503,12285256,9757435,9757435,4696274,8182522,32436,16777215,16777215,35774,35518,35518,9232634,5287378,11069692,11069691,13338717,14334887,14269352,13280650,14334887,13338717,13338717,16777215,16777215,35774,35518,35518,9232634,5287378,11069692,11069691,13338717,14334887,14269352,13280650,14334887,13338717,13338717,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,1933738,9887486,9887486,1999530,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,6329646,6329646,6329646,6329646,6329646,6461737,1079504,1481704,1083608,13225951,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11627067,11627069,14203300,14203044,11627069,9101307,9035771,30895,30895,16777215,16777215,16777215,16777215,16777215,16777215,36545,36545,11528956,11528956,13338717,13938585,13873048,13338717,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,36545,36545,11528956,11528956,13338717,13938585,13873048,13338717,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,1867431,1867431,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,2925394,2925394,2925394,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,12834019,4751365,4751365,4751365,4751365,4751365,4949019,12834019,1083608,1083608,9683686,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11231540,13872789,13806997,11231540,29868,29868,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,36545,36545,13338717,13477001,13542536,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,36545,36545,13338717,13477001,13542536,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,3726815,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,2925394,16777215,16777215,2925394,16777215,2925394,2925394,2925394,16777215,16777215,16777215,2925394,2925394,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,4158145,4158145,4158145,4158145,4158145,4158145,4158145,4158145,1079504,1083608,1079496,16777215,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11231540,13542279,13476744,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13278334,13278334,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13278334,13278334,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,2925394,16777215,16777215,2925394,16777215,2925394,2925394,2925394,16777215,16777215,2925394,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,2382006,4950739,4950739,4950739,4950739,4950739,4950739,2382006,16777215,1079496,1079496,9683686,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11231540,11231540,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,13338717,13338717,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,2925394,16777215,16777215,2925394,16777215,2925394,16777215,16777215,16777215,16777215,2925394,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,10780499,10780499,16777215,16777215,16777215,16777215,16777215,16777215,1329328,1329328,1329328,1329328,1329328,1329328,1329328,1329328,16777215,1079496,1079496,8173024,16777215,16777215,16777215,
+16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,3726815,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15602670,15602670,15602670,15602670,15602670,15602670,15602670,15602670,3726815,15602670,15602670,15602670,15602670,15602670,15602670,15602670,16777215,16777215,16777215,2925394,2925394,2925394,16777215,16777215,2925394,2925394,2925394,16777215,16777215,16777215,2925394,2925394,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215
+};
+
+
+
+static void writeIcons(QCString & dname)
+{
+int len=sizeof(verilog_icons)/sizeof(unsigned int);
+
+const int imgWidth=16;
+
+int pic=len/(imgWidth*imgWidth); 
+
+uint dist=imgWidth*pic;
+
+  for(int j=0;j<pic;j++)
+  {
+      ColoredImgDataItem cim[2];  
+	  cim[1].name=0;
+
+	  QCString file=icons_png[j];
+	  file.prepend("icon_");	
+	  QCString pngFile=file+".png";
+      
+	  uint  img[imgWidth*imgWidth];	 
+	 
+	  int temp=j*imgWidth;
+	 
+	  for(uint k=0;k<imgWidth;k++)
+	   {
+           for(uint i=0;i<imgWidth;i++)
+		   {
+			   img[k*imgWidth+i]=verilog_icons[temp+i];
+		   }
+		   temp=temp+dist;
+	   }
+		   
+		   cim[0].content=NULL;
+		   cim[0].height=imgWidth;
+		   cim[0].width=imgWidth;
+		   cim[0].icon=img;
+		   cim[0].alpha=NULL;
+		   cim[0].name=pngFile.data();
+
+		   writeColoredImgData(dname,cim);
+          
+  }
+}
+
+
 #define SPLITBAR_LINE 170,242,224,202,183,170
 #define SPLITBAR_BLOCK2  SPLITBAR_LINE    , SPLITBAR_LINE 
 #define SPLITBAR_BLOCK4  SPLITBAR_BLOCK2  , SPLITBAR_BLOCK2 
@@ -554,23 +664,23 @@
 
 static ColoredImgDataItem ftv_image_data[] =
 {
-  { "ftv2blank.png",        16,  22, blank_png,        blank_png          },
-  { "ftv2doc.png",          24,  22, doc_png,          doc_a_png          },
-  { "ftv2folderclosed.png", 24,  22, folderclosed_png, folderclosed_a_png },
-  { "ftv2folderopen.png",   24,  22, folderopen_png,   folderopen_a_png   },
-  { "ftv2ns.png",           24,  22, namespace_png,    letter_a_png       },
-  { "ftv2mo.png",           24,  22, module_png,       letter_a_png       },
-  { "ftv2cl.png",           24,  22, class_png,        letter_a_png       },
-  { "ftv2lastnode.png",     16,  22, blank_png,        blank_png          },
-  { "ftv2link.png",         24,  22, doc_png,          doc_a_png          },
-  { "ftv2mlastnode.png",    16,  22, arrow_down_png,   arrow_down_a_png   },
-  { "ftv2mnode.png",        16,  22, arrow_down_png,   arrow_down_a_png   },
-  { "ftv2node.png",         16,  22, blank_png,        blank_png          },
-  { "ftv2plastnode.png",    16,  22, arrow_right_png,  arrow_right_a_png  },
-  { "ftv2pnode.png",        16,  22, arrow_right_png,  arrow_right_a_png  },
-  { "ftv2vertline.png",     16,  22, blank_png,        blank_png          },
-  { "ftv2splitbar.png",      6,1024, splitbar_png,     0                  },
-  { 0,                       0,   0, 0,                0                  }
+  { "ftv2blank.png",        16,  22, blank_png,        blank_png    ,0      },
+  { "ftv2doc.png",          24,  22, doc_png,          doc_a_png      ,0    },
+  { "ftv2folderclosed.png", 24,  22, folderclosed_png, folderclosed_a_png,0 },
+  { "ftv2folderopen.png",   24,  22, folderopen_png,   folderopen_a_png  ,0 },
+  { "ftv2ns.png",           24,  22, namespace_png,    letter_a_png     ,0  },
+  { "ftv2mo.png",           24,  22, module_png,       letter_a_png     ,0  },
+  { "ftv2cl.png",           24,  22, class_png,        letter_a_png      ,0 },
+  { "ftv2lastnode.png",     16,  22, blank_png,        blank_png      ,0    },
+  { "ftv2link.png",         24,  22, doc_png,          doc_a_png         ,0 },
+  { "ftv2mlastnode.png",    16,  22, arrow_down_png,   arrow_down_a_png,0   },
+  { "ftv2mnode.png",        16,  22, arrow_down_png,   arrow_down_a_png  ,0 },
+  { "ftv2node.png",         16,  22, blank_png,        blank_png         ,0 },
+  { "ftv2plastnode.png",    16,  22, arrow_right_png,  arrow_right_a_png,0  },
+  { "ftv2pnode.png",        16,  22, arrow_right_png,  arrow_right_a_png  ,0},
+  { "ftv2vertline.png",     16,  22, blank_png,        blank_png          ,0},
+  { "ftv2splitbar.png",      6,1024, splitbar_png,     0                 ,0 },
+  { 0,                       0,   0, 0,                0                  ,0}
 };
 
 static int folderId=1;
@@ -578,10 +688,10 @@
 struct FTVNode
 {
   FTVNode(bool dir,const char *r,const char *f,const char *a,
-          const char *n,bool sepIndex,bool navIndex,Definition *df)
+          const char *n,bool sepIndex,bool navIndex,Definition *df,MemberDef* mdef=NULL)
     : isLast(TRUE), isDir(dir),ref(r),file(f),anchor(a),name(n), index(0),
       parent(0), separateIndex(sepIndex), addToNavIndex(navIndex),
-      def(df) { children.setAutoDelete(TRUE); }
+      def(df) ,mem(mdef){ children.setAutoDelete(TRUE); }
   int computeTreeDepth(int level) const;
   int numNodesAtLevel(int level,int maxLevel) const;
   bool isLast;
@@ -596,6 +706,7 @@
   bool separateIndex;
   bool addToNavIndex;
   Definition *def;
+  MemberDef *mem;
 };
 
 int FTVNode::computeTreeDepth(int level) const
@@ -1113,9 +1224,47 @@
       t << indentStr << "  [ ";
       generateJSLink(t,n);
       bool emptySection = !generateJSTree(navIndex,t,n->children,level+1,firstChild);
-      if (emptySection)
-        t << "null ]";
-      else
+	  Definition *def=n->def;
+	  if (emptySection)
+	  {
+		  if(def)
+		  {
+            MemberDef *med;
+			if(def->definitionType()==Definition::TypeMember)
+			{
+				med=(MemberDef*)def;
+				QCString lk=med->typeString();
+				QCString lkd=med->argsString();
+				QCString ltype;
+				int ii=med->getMemberSpecifiers();
+				if(ii==VerilogDocGen::SIGNAL)
+				{
+				 
+                ltype.setNum(4113);
+					
+					if(lkd.stripPrefix("wire"))
+					   ltype.setNum(4200);
+
+                 if(lkd.stripPrefix("reg"))
+					   ltype.setNum(4201);
+
+
+				}
+				else
+				ltype.setNum(ii);
+			
+				t<<"null,\"";
+	        	t<<ltype.data();
+		       t<<"\"]";			
+			
+			}
+		  }
+		  else 
+				t<<"null ]";
+           
+      
+	  }
+	  else
         t << endl << indentStr << "  ] ]"; 
     }
   }
@@ -1224,6 +1373,15 @@
 void FTVHelp::generateTreeViewImages()
 {
   QCString dname=Config_getString("HTML_OUTPUT");
+writeIcons(dname); 
+/*
+if(Config_getBool("OPTIMIZE_OUTPUT_VERILOG"))
+{
+	ftv_image_data[6].icon=vmodule_icon;
+    ftv_image_data[6].width=16;
+   ftv_image_data[6].height=16;
+}
+*/
   writeColoredImgData(dname,ftv_image_data);
 }
 
Index: src/vhdldocgen.h
===================================================================
--- src/vhdldocgen.h	(Revision 818)
+++ src/vhdldocgen.h	(Arbeitskopie)
@@ -276,6 +276,10 @@
     static QCString  parseForBinding(QCString & entity,QCString & arch);
     static void addBaseClass(ClassDef* cd,ClassDef *ent);
 
+	static void writeOverview(OutputList & g_outputList);
+    static void writeOverview();
+  static void adjustRecordMember(MemberDef *mdef);
+  static void writeUCFLink(const MemberDef* mdef,OutputList &ol);
   private:
     static void findAllArchitectures(QList<QCString>& ql,const ClassDef *cd);
     static bool compareArgList(ArgumentList*,ArgumentList*);
Index: src/index.cpp
===================================================================
--- src/index.cpp	(Revision 818)
+++ src/index.cpp	(Arbeitskopie)
@@ -43,6 +43,7 @@
 #include "dirdef.h"
 #include "vhdldocgen.h"
 #include "layout.h"
+#include "verilogdocgen.h"
 
 #define MAX_ITEMS_BEFORE_MULTIPAGE_INDEX 200
 #define MAX_ITEMS_BEFORE_QUICK_INDEX 30
@@ -325,9 +326,12 @@
             {
               if (md->getOuterScope()==def)
               {
-                Doxygen::indexList.addContentsItem(FALSE,
-                  md->name(),md->getReference(),md->getOutputFileBase(),md->anchor(),FALSE,addToIndex);
-              }
+				  if(md->getMemberSpecifiers()!=VerilogDocGen::PORT && Config_getBool("OPTIMIZE_OUTPUT_VERILOG"))
+				  {
+					  Doxygen::indexList.addContentsItem(FALSE,
+                  md->name(),md->getReference(),md->getOutputFileBase(),md->anchor(),FALSE,addToIndex,md);
+				  }
+				  }
               else // inherited member
               {
                 Doxygen::indexList.addContentsItem(FALSE,
@@ -2156,7 +2160,11 @@
   static bool hideFriendCompounds = Config_getBool("HIDE_FRIEND_COMPOUNDS");
   ClassDef *cd=0;
 
- 
+   if ( md->getLanguage()==SrcLangExt_VERILOG) // &&  (VhdlDocGen::isRecord(md) || VhdlDocGen::isUnit(md)))
+  {
+    VhdlDocGen::adjustRecordMember(md);
+  }
+
   
   if (md->isLinkableInProject() && 
       (cd=md->getClassDef())    && 
Index: src/memberdef.h
===================================================================
--- src/memberdef.h	(Revision 818)
+++ src/memberdef.h	(Arbeitskopie)
@@ -51,7 +51,7 @@
   public:
     
     enum MemberType { 
-      Define,
+      Define=9,
       Function, 
       Variable, 
       Typedef, 
@@ -366,7 +366,8 @@
     void findSectionsInDocumentation();
     
     bool visited;
-   
+   QCString getDefinition() const;
+
   protected:
     void flushToDisk() const;
     void loadFromDisk() const;
Index: src/definition.h
===================================================================
--- src/definition.h	(Revision 818)
+++ src/definition.h	(Arbeitskopie)
@@ -19,6 +19,7 @@
 #define DEFINITION_H
 
 #include "qtbc.h"
+#include "qstringlist.h"
 #include <qlist.h>
 #include <qdict.h>
 #include <sys/types.h>
@@ -332,7 +333,11 @@
 
     void addSectionsToIndex();
     void writeToc(OutputList &ol);
+void addListType(QCString q);
+    
 
+	QStringList& getList();
+
   protected:
 
     virtual void flushToDisk() const;
@@ -360,6 +365,8 @@
     bool m_isSymbol;
     QCString m_symbolName;
     int m_defLine;
+    QStringList qsl;
+
 };
 
 class DefinitionList : public QList<Definition>, public DefinitionIntf
Index: src/vhdlparser.y
===================================================================
--- src/vhdlparser.y	(Revision 818)
+++ src/vhdlparser.y	(Arbeitskopie)
@@ -1245,7 +1245,7 @@
                   addVhdlType($2,getParsedLine(t_ATTRIBUTE),Entry::VARIABLE_SEC,VhdlDocGen::ATTRIBUTE,0,oo.data());
                 }
 
-entity_spec : entity_name_list signature  t_Colon entity_class
+entity_spec : entity_name_list signature  t_Colon entity_class { $$=$1+$2+":"+$4;}	
 
 entity_name_list:   designator entity_name_list_1         { $$=$1+" "+$2; }
 entity_name_list:   t_OTHERS                              { $$="others";  }
@@ -1263,7 +1263,7 @@
 entity_class: t_TYPE          { $$="type";          }
 entity_class: t_SUBTYPE       { $$="subtype";       }
 entity_class: t_PROCEDURE     { $$="procedure";     }
-entity_class: t_FUNCTION      { $$="";              }
+entity_class: t_FUNCTION      { $$="function";              }
 entity_class: t_SIGNAL        { $$="signal";        }
 entity_class: t_VARIABLE      { $$="variable";      }
 entity_class: t_CONSTANT      { $$="constant";      }
Index: src/vhdldocgen.cpp
===================================================================
--- src/vhdldocgen.cpp	(Revision 818)
+++ src/vhdldocgen.cpp	(Arbeitskopie)
@@ -1,2863 +1,3462 @@
-/******************************************************************************
- *
- * Copyright (C) 1997-2012 by Dimitri van Heesch.
- *
- * Permission to use, copy, modify, and distribute this software and its
- * documentation under the terms of the GNU General Public License is hereby
- * granted. No representations are made about the suitability of this software
- * for any purpose. It is provided "as is" without express or implied warranty.
- * See the GNU General Public License for more details.
- *
- * Documents produced by Doxygen are derivative works derived from the
- * input used in their production; they are not affected by this license.
- *
- */
-/******************************************************************************
- * Parser for VHDL subset
- * written by M. Kreis
- * supports VHDL-87/93/2002
- * does not support VHDL-AMS
- ******************************************************************************/
-
-// global includes
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <qcstring.h>
-#include <qfileinfo.h>
-#include <qstringlist.h>
-#include "memberdef.h"
-/* --------------------------------------------------------------- */
-
-// local includes
-#include "vhdldocgen.h"
-#include "message.h"
-#include "config.h"
-#include "doxygen.h"
-#include "util.h"
-#include "language.h"
-#include "commentscan.h"
-#include "index.h"
-#include "definition.h"
-#include "searchindex.h"
-#include "outputlist.h"
-#include "parserintf.h"
-#include "vhdlscanner.h"
-#include "layout.h"
-#include "arguments.h"
-
-
-#define theTranslator_vhdlType VhdlDocGen::trVhdlType
-
-static QDict<QCString> g_vhdlKeyDict0(17,FALSE);
-static QDict<QCString> g_vhdlKeyDict1(17,FALSE);
-static QDict<QCString> g_vhdlKeyDict2(17,FALSE);
-
-static QDict<QCString> g_xilinxUcfDict(17,FALSE);
-
-static void initUCF(Entry* root,const char* type,QCString &  qcs,int line,QCString & fileName,QCString & brief);
-static void writeUCFLink(const MemberDef* mdef,OutputList &ol);
-static void assignConfiguration(ConfNode* ,QCString);
-static void assignBinding(ConfNode* conf,QCString label);
-static void addInstance(ClassDef* entity, ClassDef* arch, ClassDef *inst,Entry *cur,ClassDef* archBind=NULL);
-
-#if 0
-static ConfNode* findConfiguration(QCString config)
-{
-  QList<ConfNode> confList= getVhdlConfiguration();
-  uint size=confList.count();
-  if (size==0) return NULL;
-
-  for (uint i=0;i<size;i++)
-  {
-    ConfNode* conf= (ConfNode *)confList.at(i);
-    QCString entity=VhdlDocGen::getIndexWord(conf->confVhdl.data(),1);
-    if (entity==config)
-    {
-      return conf;
-    }
-  }
-
-  return NULL;
-}
-#endif
-
-VhdlDocGen::VhdlDocGen()
-{
-}
-
-VhdlDocGen::~VhdlDocGen()
-{
-}
-
-void VhdlDocGen::init()
-{
-
- // vhdl keywords inlcuded VHDL 2008
-const char* g_vhdlKeyWordMap0[] =
-{
-  "abs","access","after","alias","all","and","architecture","array","assert","assume","assume_guarantee","attribute",
-  "begin","block","body","buffer","bus",
-  "case","component","configuration","constant","context","cover",
-  "default","disconnect","downto",
-  "else","elsif","end","entity","exit",
-  "fairness","file","for","force","function",
-  "generate","generic","group","guarded",
-  "if","impure","in","inertial","inout","is",
-  "label","library","linkage","literal","loop",
-  "map","mod",
-  "nand","new","next","nor","not","null",
-  "of","on","open","or","others","out",
-  "package","parameter","port","postponed","procedure","process","property","proctected","pure",
-  "range","record","register","reject","release","restrict","restrict_guarantee","rem","report","rol","ror","return",
-  "select","sequence","severity","signal","shared","sla","sll","sra","srl","strong","subtype",
-  "then","to","transport","type",
-  "unaffected","units","until","use",
-  "variable","vmode","vprop","vunit",
-  "wait","when","while","with",
-  "xor","xnor",
-  0
-};
-
-// type
-const char* g_vhdlKeyWordMap1[] =
-{
-  "natural","unsigned","signed","string","boolean", "bit","bit_vector","character",
-  "std_ulogic","std_ulogic_vector","std_logic","std_logic_vector","integer",
-  "real","float","ufixed","sfixed","time",0
-};
-
-// logic
-const char* g_vhdlKeyWordMap2[] =
-{
-  "abs","and","or","not","mod", "xor","rem","xnor","ror","rol","sla",
-  "sll",0
-};
-
-  int j=0;
-  g_vhdlKeyDict0.setAutoDelete(TRUE);
-  g_vhdlKeyDict1.setAutoDelete(TRUE);
-  g_vhdlKeyDict2.setAutoDelete(TRUE);
-
-  j=0;
-  while (g_vhdlKeyWordMap0[j])
-  {
-    g_vhdlKeyDict0.insert(g_vhdlKeyWordMap0[j],
-	               new QCString(g_vhdlKeyWordMap0[j]));
-    j++;
-  }
-
-  j=0;
-  while (g_vhdlKeyWordMap1[j])
-  {
-    g_vhdlKeyDict1.insert(g_vhdlKeyWordMap1[j],
-	               new QCString(g_vhdlKeyWordMap1[j]));
-    j++;
-  }
-
-  j=0;
-  while (g_vhdlKeyWordMap2[j])
-  {
-    g_vhdlKeyDict2.insert(g_vhdlKeyWordMap2[j],
-	               new QCString(g_vhdlKeyWordMap2[j]));
-    j++;
-  }
-
-}// buildKeyMap
-
-/*!
- * returns the color of a keyword
- */
-
-QCString* VhdlDocGen::findKeyWord(const QCString& word)
-{
-  static  QCString g_vhdlkeyword("vhdlkeyword");
-  static  QCString g_vhdltype("comment");
-  static  QCString g_vhdllogic("vhdllogic");
-
-  if (word.isEmpty() || word.at(0)=='\0') return 0;
-  //printf("VhdlDocGen::findKeyWord(%s)\n",word.data());
-
-  if (g_vhdlKeyDict0.find(word.lower()))
-    return &g_vhdlkeyword;
-
-  if (g_vhdlKeyDict1.find(word.lower()))
-    return &g_vhdltype;
-
-  if (g_vhdlKeyDict2.find(word.lower()))
-    return &g_vhdllogic;
-
-  return 0;
-}
-
-/*!
- * returns the parsed entry at line xxx
- */
-
-
-
-bool found =FALSE;
-static Entry eMerge;
-
-ClassDef *VhdlDocGen::getClass(const char *name)
-{
-  if (name==0 || name[0]=='\0') return 0;
-
-  ClassDef *cd=0;
-  QCString temp(name);
-  //temp=temp.lower();
-  temp=temp.stripWhiteSpace();
-  cd= Doxygen::classSDict->find(temp.data());
-  return cd;
-}
-
-
-
-
-ClassDef* VhdlDocGen::getPackageName(const QCString & name)
-{
-  ClassDef* cd=0;
-  QStringList ql=QStringList::split(".",name,FALSE);
-  cd=getClass(name);
-
-  return cd;
-}
-
-MemberDef* VhdlDocGen::findMember(const QCString& className, const QCString& memName)
-{
-  QDict<QCString> packages(17,FALSE);
-  packages.setAutoDelete(TRUE);
-  ClassDef* cd;
-  MemberDef *mdef=0;
-
-  cd=getClass(className);
-  //printf("VhdlDocGen::findMember(%s,%s)=%p\n",className.data(),memName.data(),cd);
-  if (cd==0) return 0;
-
-  mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::variableMembers);
-  if (mdef) return mdef;
-  mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
-  if (mdef) return mdef;
-
-  // nothing found so far
-  // if we are an architecture or package body search in entitiy
-
-  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS ||
-      (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
-  {
-    Definition *d = cd->getOuterScope();
-    // searching upper/lower case names
-
-    QCString tt=d->name();
-    ClassDef *ecd =getClass(tt);
-    if (!ecd)
-    {
-      tt=tt.upper();
-      ecd =getClass(tt);
-    }
-    if (!ecd)
-    {
-      tt=tt.lower();
-      ecd =getClass(tt);
-    }
-
-    if (ecd) //d && d->definitionType()==Definition::TypeClass)
-    {
-      //ClassDef *ecd = (ClassDef*)d;
-      mdef=VhdlDocGen::findMemberDef(ecd,memName,MemberList::variableMembers);
-      if (mdef) return mdef;
-      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
-      if (mdef) return mdef;
-    }
-    //cd=getClass(getClassName(cd));
-    //if (!cd) return 0;
-  }
-  // nothing found , so we are now searching all included packages
-  VhdlDocGen::findAllPackages(className,packages);
-  //cd=getClass(className.data());
-  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS ||
-      (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
-  {
-    Definition *d = cd->getOuterScope();
-
-    QCString tt=d->name();
-    ClassDef *ecd =getClass(tt);
-    if (!ecd)
-    {
-      tt=tt.upper();
-      ecd =getClass(tt);
-    }
-    if (!ecd)
-    {
-      tt=tt.lower();
-      ecd =getClass(tt);
-    }
-
-    if (ecd) //d && d->definitionType()==Definition::TypeClass)
-    {
-      VhdlDocGen::findAllPackages(ecd->className(),packages);
-    }
-  }
-
-  QDictIterator<QCString> packli(packages);
-  QCString *curString;
-  for (packli.toFirst();(curString=packli.current());++packli)
-  {
-    if (curString)
-    {
-      cd=VhdlDocGen::getPackageName(*curString);
-      if (!cd)
-      {
-        *curString=curString->upper();
-        cd=VhdlDocGen::getPackageName(*curString);
-      }
-      if (!cd)
-      {
-        *curString=curString->lower();
-        cd=VhdlDocGen::getPackageName(*curString);
-      }
-    }
-    if (cd)
-    {
-      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::variableMembers);
-      if (mdef)  return mdef;
-      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
-      if (mdef) return mdef;
-    }
-  } // for
-  return 0;
-}//findMember
-
-/**
- *  This function returns the entity|package
- *  in which the key (type) is found
- */
-
-MemberDef* VhdlDocGen::findMemberDef(ClassDef* cd,const QCString& key,MemberList::ListType type)
-{
-  //    return cd->getMemberByName(key);//does not work
-  MemberDef *md=0;
-
-  MemberList *ml=    cd->getMemberList(type);
-  if (ml==0) return 0;
-
-  MemberListIterator fmni(*ml);
-
-  for (fmni.toFirst();(md=fmni.current());++fmni)
-  {
-    if (stricmp(key.data(),md->name().data())==0)
-    {
-      return md;
-    }
-  }
-  return 0;
-}//findMemberDef
-
-/*!
- * finds all included packages of an Entity or Package
- */
-
-void VhdlDocGen::findAllPackages(const QCString& className,QDict<QCString>& qdict)
-{
-  ClassDef *cdef=getClass(className);
-  if (cdef)
-  {
-    MemberList *mem=cdef->getMemberList(MemberList::variableMembers);
-    MemberDef *md;
-
-    if (mem)
-    {
-      MemberListIterator fmni(*mem);
-      for (fmni.toFirst();(md=fmni.current());++fmni)
-      {
-        if (VhdlDocGen::isPackage(md))
-        {
-          QCString *temp1=new QCString(md->name().data());
-          //*temp1=temp1->lower();
-          QCString p(md->name().data());
-          //p=p.lower();
-          ClassDef* cd=VhdlDocGen::getPackageName(*temp1);
-          if (cd)
-          {
-            QCString *ss=qdict.find(*temp1);
-            if (ss==0)
-            {
-              qdict.insert(p,temp1);
-              QCString tmp=cd->className();
-              VhdlDocGen::findAllPackages(tmp,qdict);
-            }
-            else delete temp1;
-          }
-          else delete temp1;
-        }
-      }//for
-    }//if
-  }//cdef
-}// findAllPackages
-
-/*!
- * returns the function with the matching argument list
- * is called in vhdlcode.l
- */
-
-MemberDef* VhdlDocGen::findFunction(const QList<Argument> &ql,
-    const QCString& funcname,
-    const QCString& package, bool /*type*/)
-{
-  MemberDef* mdef=0;
-  //int funcType;
-  ClassDef *cdef=getClass(package.data());
-  if (cdef==0) return 0;
-
-  //if (type)
-  //  funcType=VhdlDocGen::PROCEDURE;
-  //else
-  //  funcType=VhdlDocGen::FUNCTION;
-
-  MemberList *mem=cdef->getMemberList(MemberList::pubMethods);
-
-  if (mem)
-  {
-    MemberListIterator fmni(*mem);
-    for (fmni.toFirst();(mdef=fmni.current());++fmni)
-    {
-      QCString mname=mdef->name();
-      if ((VhdlDocGen::isProcedure(mdef) || VhdlDocGen::isVhdlFunction(mdef)) && (VhdlDocGen::compareString(funcname,mname)==0))
-      {
-        LockingPtr<ArgumentList> alp = mdef->argumentList();
-
-        //  ArgumentList* arg2=mdef->getArgumentList();
-        if (alp==0) break;
-        ArgumentListIterator ali(*alp.pointer());
-        ArgumentListIterator ali1(ql);
-
-        if (ali.count() != ali1.count()) break;
-
-        Argument *arg,*arg1;
-        int equ=0;
-
-        for (;(arg=ali.current());++ali)
-        {
-          arg1=ali1.current(); ++ali1;
-          equ+=abs(VhdlDocGen::compareString(arg->type,arg1->type));
-
-          QCString s1=arg->type;
-          QCString s2=arg1->type;
-          VhdlDocGen::deleteAllChars(s1,' ');
-          VhdlDocGen::deleteAllChars(s2,' ');
-          equ+=abs(VhdlDocGen::compareString(s1,s2));
-          s1=arg->attrib;
-          s2=arg1->attrib;
-          VhdlDocGen::deleteAllChars(s1,' ');
-          VhdlDocGen::deleteAllChars(s2,' ');
-          equ+=abs(VhdlDocGen::compareString(s1,s2));
-          // printf("\n 1. type [%s] name [%s] attrib [%s]",arg->type,arg->name,arg->attrib);
-          // printf("\n 2. type [%s] name [%s] attrib [%s]",arg1->type,arg1->name,arg1->attrib);
-        } // for
-        if (equ==0) return mdef;
-      }//if
-    }//for
-  }//if
-  return mdef;
-} //findFunction
-
-
-
-
-/*!
- * returns the class title+ref
- */
-
-QCString VhdlDocGen::getClassTitle(const ClassDef *cd)
-{
-  QCString pageTitle;
-  if (cd==0) return "";
-  pageTitle+=cd->displayName();
-  pageTitle=VhdlDocGen::getClassName(cd);
-  int ii=cd->protection();
-  pageTitle+=" ";
-  pageTitle+=theTranslator_vhdlType(ii+2,TRUE);
-  pageTitle+=" ";
-  return pageTitle;
-} // getClassTitle
-
-/* returns the class name without their prefixes */
-
-QCString VhdlDocGen::getClassName(const ClassDef* cd)
-{
-  QCString temp;
-  if (cd==0) return "";
-
-  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
-  {
-    temp=cd->name();
-    temp.stripPrefix("_");
-    return temp;
-  }
-  //if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS)
-  //{
-  //  QStringList qlist=QStringList::split("-",cd->className(),FALSE);
-  //  if (qlist.count()>1)
-  //    return (QCString)qlist[1];
-  //  return "";
-  //}
-  return substitute(cd->className(),"::",".");
-}
-
-/*!
- * writes an inline link form entity|package to architecture|package body and vice verca
- */
-
-void VhdlDocGen::writeInlineClassLink(const ClassDef* cd ,OutputList& ol)
-{
-  QList<QCString> ql;
-  ql.setAutoDelete(TRUE);
-  QCString nn=cd->className();
-  int ii=(int)cd->protection()+2;
-
-  QCString type;
-  if (ii==VhdlDocGen::ENTITY)
-    type+=theTranslator_vhdlType(VhdlDocGen::ARCHITECTURE,TRUE);
-  else if (ii==VhdlDocGen::ARCHITECTURE)
-    type+=theTranslator_vhdlType(VhdlDocGen::ENTITY,TRUE);
-  else if (ii==VhdlDocGen::PACKAGE_BODY)
-    type+=theTranslator_vhdlType(VhdlDocGen::PACKAGE,TRUE);
-  else if (ii==VhdlDocGen::PACKAGE)
-    type+=theTranslator_vhdlType(VhdlDocGen::PACKAGE_BODY,TRUE);
-  else
-    type+="";
-
-  //type=type.lower();
-  type+=" >> ";
-  ol.disable(OutputGenerator::RTF);
-  ol.disable(OutputGenerator::Man);
-
-  if (ii==VhdlDocGen::PACKAGE_BODY)
-  {
-    nn.stripPrefix("_");
-    cd=getClass(nn.data());
-  }
-  else  if (ii==VhdlDocGen::PACKAGE)
-  {
-    nn.prepend("_");
-    cd=getClass(nn.data());
-  }
-  else if (ii==VhdlDocGen::ARCHITECTURE)
-  {
-    QStringList qlist=QStringList::split("-",nn,FALSE);
-    nn=qlist[1].utf8();
-    cd=VhdlDocGen::getClass(nn.data());
-  }
-
-  QCString opp;
-  if (ii==VhdlDocGen::ENTITY)
-  {
-    VhdlDocGen::findAllArchitectures(ql,cd);
-    int j=ql.count();
-    for (int i=0;i<j;i++)
-    {
-      QCString *temp=ql.at(i);
-      QStringList qlist=QStringList::split("-",*temp,FALSE);
-      QCString s1=qlist[0].utf8();
-      QCString s2=qlist[1].utf8();
-      s1.stripPrefix("_");
-      if (j==1) s1.resize(0);
-      ClassDef*cc = getClass(temp->data());
-      if (cc)
-      {
-        VhdlDocGen::writeVhdlLink(cc,ol,type,s2,s1);
-      }
-    }
-  }
-  else
-  {
-    VhdlDocGen::writeVhdlLink(cd,ol,type,nn,opp);
-  }
-
-  ol.enable(OutputGenerator::Man);
-  ol.enable(OutputGenerator::RTF);
-
-}// write
-
-/*
- * finds all architectures which belongs to an entiy
- */
-void VhdlDocGen::findAllArchitectures(QList<QCString>& qll,const ClassDef *cd)
-{
-  ClassDef *citer;
-  ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for ( ; (citer=cli.current()) ; ++cli )
-  {
-    QCString jj=citer->className();
-    if (cd != citer && jj.contains('-')!=-1)
-    {
-      QStringList ql=QStringList::split("-",jj,FALSE);
-      QCString temp=ql[1].utf8();
-      if (stricmp(cd->className().data(),temp.data())==0)
-      {
-        QCString *cl=new QCString(jj.data());
-        qll.insert(0,cl);
-      }
-    }
-  }// for
-}//findAllArchitectures
-
-ClassDef* VhdlDocGen::findArchitecture(const ClassDef *cd)
-{
-  ClassDef *citer;
-  QCString nn=cd->name();
-  ClassSDict::Iterator cli(*Doxygen::classSDict);
-
-  for ( ; (citer=cli.current()) ; ++cli )
-  {
-    QCString jj=citer->name();
-    QStringList ql=QStringList::split(":",jj,FALSE);
-    if (ql.count()>1)
-    {
-      if (ql[0].utf8()==nn )
-      {
-        return citer;
-      }
-    }
-  }
-  return 0;
-}
-/*
- * writes the link entity >> .... or architecture >> ...
- */
-
-void VhdlDocGen::writeVhdlLink(const ClassDef* ccd ,OutputList& ol,QCString& type,QCString& nn,QCString& behav)
-{
-  if (ccd==0)  return;
-  QCString temp=ccd->getOutputFileBase();
-  ol.startBold();
-  ol.docify(type.data());
-  ol.endBold();
-  nn.stripPrefix("_");
-  ol.writeObjectLink(ccd->getReference(),ccd->getOutputFileBase(),0,nn.data());
-
-  if (!behav.isEmpty())
-  {
-    behav.prepend("  ");
-    ol.startBold();
-    ol.docify(behav.data());
-    ol.endBold();
-  }
-
-  ol.lineBreak();
-}
-
-bool VhdlDocGen::compareString(const QCString& s1,const QCString& s2)
-{
-  QCString str1=s1.stripWhiteSpace();
-  QCString str2=s2.stripWhiteSpace();
-
-  return stricmp(str1.data(),str2.data());
-}
-
-
-/*!
- * strips the "--" prefixes of vhdl comments
- */
-void VhdlDocGen::prepareComment(QCString& qcs)
-{
-  const char* s="--!";
-  //const char *start="--!{";
-  //const char *end="--!}";
-  int index=0;
-
-  while (TRUE)
-  {
-    index=qcs.find(s,0,TRUE);
-    if (index<0) break;
-    qcs=qcs.remove(index,strlen(s));
-  }
-  qcs=qcs.stripWhiteSpace();
-}
-
-
-/*!
- * parses a function proto
- * @param text function string
- * @param qlist stores the function types
- * @param name points to the function name
- * @param ret Stores the return type
- * @param doc ???
- */
-void VhdlDocGen::parseFuncProto(const char* text,QList<Argument>& qlist,
-    QCString& name,QCString& ret,bool doc)
-{
-  (void)qlist; //unused
-  int index,end;
-  QCString s1(text);
-  QCString temp;
-
-  index=s1.find("(");
-  end=s1.findRev(")");
-
-  if ((end-index)>0)
-  {
-    QCString tt=s1.mid(index,(end-index+1));
-    temp=s1.mid(index+1,(end-index-1));
-    //getFuncParams(qlist,temp);
-  }
-  if (doc)
-  {
-    name=s1.left(index);
-    name=name.stripWhiteSpace();
-    if ((end-index)>0)
-    {
-      ret="function";
-    }
-    return;
-  }
-  else
-  {
-    QCString s1(text);
-    s1=s1.stripWhiteSpace();
-    int i=s1.find("(",0,FALSE);
-    int s=s1.find(QRegExp("[ \\t]"));
-    if (i==-1 || i<s)
-      s1=VhdlDocGen::getIndexWord(s1.data(),1);
-    else // s<i, s=start of name, i=end of name
-      s1=s1.mid(s,(i-s));
-
-    name=s1.stripWhiteSpace();
-  }
-  index=s1.findRev("return",-1,FALSE);
-  if (index !=-1)
-  {
-    ret=s1.mid(index+6,s1.length());
-    ret=ret.stripWhiteSpace();
-    VhdlDocGen::deleteCharRev(ret,';');
-  }
-}
-
-/*
- *  returns the n'th word of a string
- */
-
-QCString VhdlDocGen::getIndexWord(const char* c,int index)
-{
-  QStringList ql;
-  QCString temp(c);
-  QRegExp reg("[\\s:|]");
-
-  ql=QStringList::split(reg,temp,FALSE);
-
-  if (ql.count() > (unsigned int)index)
-  {
-    return ql[index].utf8();
-  }
-
-  return "";
-}
-
-
-QCString VhdlDocGen::getProtectionName(int prot)
-{
-  if (prot==VhdlDocGen::ENTITYCLASS)
-    return "entity";
-  else if (prot==VhdlDocGen::ARCHITECTURECLASS)
-    return "architecture";
-  else if (prot==VhdlDocGen::PACKAGECLASS)
-    return "package";
-  else if (prot==VhdlDocGen::PACKBODYCLASS)
-    return "package body";
-
-  return "";
-}
-
-QCString VhdlDocGen::trTypeString(int type)
-{
-  switch(type)
-  {
-    case VhdlDocGen::LIBRARY:        return "Library";
-    case VhdlDocGen::ENTITY:         return "Entity";
-    case VhdlDocGen::PACKAGE_BODY:   return "Package Body";
-    case VhdlDocGen::ATTRIBUTE:      return "Attribute";
-    case VhdlDocGen::PACKAGE:        return "Package";
-    case VhdlDocGen::SIGNAL:         return "Signal";
-    case VhdlDocGen::COMPONENT:      return "Component";
-    case VhdlDocGen::CONSTANT:       return "Constant";
-    case VhdlDocGen::TYPE:           return "Type";
-    case VhdlDocGen::SUBTYPE:        return "Subtype";
-    case VhdlDocGen::FUNCTION:       return "Function";
-    case VhdlDocGen::RECORD:         return "Record";
-    case VhdlDocGen::PROCEDURE:      return "Procedure";
-    case VhdlDocGen::ARCHITECTURE:   return "Architecture";
-    case VhdlDocGen::USE:            return "Package";
-    case VhdlDocGen::PROCESS:        return "Process";
-    case VhdlDocGen::PORT:           return "Port";
-    case VhdlDocGen::GENERIC:        return "Generic";
-    case VhdlDocGen::UNITS:          return "Units";
-                                     //case VhdlDocGen::PORTMAP:        return "Port Map";
-    case VhdlDocGen::SHAREDVARIABLE: return "Shared Variable";
-    case VhdlDocGen::GROUP:          return "Group";
-    case VhdlDocGen::VFILE:          return "File";
-    case VhdlDocGen::INSTANTIATION: return "Instantiation";
-    case VhdlDocGen::ALIAS:          return "Alias";
-    case VhdlDocGen::CONFIG:         return "Configuration";
-    case VhdlDocGen::MISCELLANEOUS:  return "Miscellaneous";
-    case VhdlDocGen::UCF_CONST:      return "Constraints";
-    default:                         return "";
-  }
-} // convertType
-
-/*!
- * deletes a char backwards in a string
- */
-
-bool VhdlDocGen::deleteCharRev(QCString &s,char c)
-{
-  int index=s.findRev(c,-1,FALSE);
-  if (index > -1)
-  {
-    QCString qcs=s.remove(index,1);
-    s=qcs;
-    return TRUE;
-  }
-  return FALSE;
-}
-
-void VhdlDocGen::deleteAllChars(QCString &s,char c)
-{
-  int index=s.findRev(c,-1,FALSE);
-  while (index > -1)
-  {
-    QCString qcs=s.remove(index,1);
-    s=qcs;
-    index=s.findRev(c,-1,FALSE);
-  }
-}
-
-
-static int recordCounter=0;
-
-/*!
- * returns the next number of a record|unit member
- */
-
-QCString VhdlDocGen::getRecordNumber()
-{
-  char buf[12];
-  sprintf(buf,"%d",recordCounter++);
-  QCString qcs(&buf[0]);
-  return qcs;
-}
-
-/*!
- * returns the next number of an anonymous process
- */
-
-QCString VhdlDocGen::getProcessNumber()
-{
-  static int stringCounter;
-  char buf[8];
-  QCString qcs("PROCESS_");
-  sprintf(buf,"%d",stringCounter++);
-  qcs.append(&buf[0]);
-  return qcs;
-}
-
-/*!
- * writes a colored and formatted string
- */
-
-void VhdlDocGen::writeFormatString(const QCString& s,OutputList&ol,const MemberDef* mdef)
-{
-  QRegExp reg("[\\[\\]\\.\\/\\:\\<\\>\\:\\s\\,\\;\\'\\+\\-\\*\\|\\&\\=\\(\\)\"]");
-  QCString qcs = s;
-  qcs+=QCString(" ");// parsing the last sign
-  QCString *ss;
-  QCString find=qcs;
-  QCString temp=qcs;
-  char buf[2];
-  buf[1]='\0';
-
-  int j;
-  int len;
-  j = reg.match(temp.data(),0,&len);
-
-  ol.startBold();
-  if (j>=0)
-  {
-    while (j>=0)
-    {
-      find=find.left(j);
-      buf[0]=temp[j];
-      ss=VhdlDocGen::findKeyWord(find);
-      bool k=VhdlDocGen::isNumber(find); // is this a number
-      if (k)
-      {
-        ol.docify(" ");
-        VhdlDocGen::startFonts(find,"vhdldigit",ol);
-        ol.docify(" ");
-      }
-      else if (j != 0 && ss)
-      {
-        VhdlDocGen::startFonts(find,ss->data(),ol);
-      }
-      else
-      {
-        if (j>0)
-        {
-          VhdlDocGen::writeStringLink(mdef,find,ol);
-        }
-      }
-      VhdlDocGen::startFonts(&buf[0],"vhdlchar",ol);
-
-      QCString st=temp.remove(0,j+1);
-      find=st;
-      if (!find.isEmpty() && find.at(0)=='"')
-      {
-        int ii=find.find('"',2);
-        if (ii>1)
-        {
-          QCString com=find.left(ii+1);
-          VhdlDocGen::startFonts(com,"keyword",ol);
-          temp=find.remove(0,ii+1);
-        }
-      }
-      else
-      {
-        temp=st;
-      }
-      j = reg.match(temp.data(),0,&len);
-    }//while
-  }//if
-  else
-  {
-    VhdlDocGen::startFonts(find,"vhdlchar",ol);
-  }
-  ol.endBold();
-}// writeFormatString
-
-/*!
- * returns TRUE if this string is a number
- */
-
-bool VhdlDocGen::isNumber(const QCString& s)
-{
-  static QRegExp regg("[0-9][0-9eEfFbBcCdDaA_.#-+?xXzZ]*");
-
-  if (s.isEmpty()) return FALSE;
-  int j,len;
-  j = regg.match(s.data(),0,&len);
-  if ((j==0) && (len==(int)s.length())) return TRUE;
-  return FALSE;
-
-}// isNumber
-
-void VhdlDocGen::startFonts(const QCString& q, const char *keyword,OutputList& ol)
-{
-  ol.startFontClass(keyword);
-  ol.docify(q.data());
-  ol.endFontClass();
-}
-
-/*!
- * inserts white spaces for  better readings
- * and writes a colored string to the output
- */
-
-void VhdlDocGen::formatString(const QCString &s, OutputList& ol,const MemberDef* mdef)
-{
-  QCString qcs = s;
-  QCString temp(qcs.length());
-  qcs.stripPrefix(":");
-  qcs.stripPrefix("is");
-  qcs.stripPrefix("IS");
-  qcs.stripPrefix("of");
-  qcs.stripPrefix("OF");
-
-  // VhdlDocGen::deleteCharRev(qcs,';');
-  //char white='\t';
-  int len = qcs.length();
-  unsigned int index=1;//temp.length();
-
-  for (int j=0;j<len;j++)
-  {
-    char c=qcs[j];
-    char b=c;
-    if (j>0) b=qcs[j-1];
-    if (c=='"' || c==',' || c=='\''|| c=='(' || c==')'  || c==':' || c=='[' || c==']' ) // || (c==':' && b!='=')) // || (c=='=' && b!='>'))
-    {
-      if (temp.at(index-1) != ' ')
-      {
-        temp+=" ";
-      }
-      temp+=c;
-      temp+=" ";
-    }
-    else if (c=='=')
-    {
-      if (b==':') // := operator
-      {
-        temp.replace(index-1,1,"=");
-        temp+=" ";
-      }
-      else // = operator
-      {
-        temp+=" ";
-        temp+=c;
-        temp+=" ";
-      }
-    }
-    else
-    {
-      temp+=c;
-    }
-
-    index=temp.length();
-  }// for
-  temp=temp.stripWhiteSpace();
-  // printf("\n [%s]",qcs.data());
-  VhdlDocGen::writeFormatString(temp,ol,mdef);
-}
-
-/*!
- * writes a procedure prototype to the output
- */
-
-void VhdlDocGen::writeProcedureProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
-{
-  ArgumentListIterator ali(*al);
-  Argument *arg;
-  bool sem=FALSE;
-  int len=al->count();
-  ol.docify("( ");
-  if (len > 2)
-  {
-    ol.lineBreak();
-  }
-  for (;(arg=ali.current());++ali)
-  {
-    ol.startBold();
-    if (sem && len <3)
-      ol.writeChar(',');
-
-    QCString nn=arg->name;
-    nn+=": ";
-
-    QCString *str=VhdlDocGen::findKeyWord(arg->defval);
-    arg->defval+=" ";
-    if (str)
-    {
-      VhdlDocGen::startFonts(arg->defval,str->data(),ol);
-    }
-    else
-    {
-      VhdlDocGen::startFonts(arg->defval,"vhdlchar",ol); // write type (variable,constant etc.)
-    }
-
-    VhdlDocGen::startFonts(nn,"vhdlchar",ol); // write name
-    if (stricmp(arg->attrib.data(),arg->type.data()) != 0)
-      VhdlDocGen::startFonts(arg->attrib.lower(),"stringliteral",ol); // write in|out
-    ol.docify(" ");
-    VhdlDocGen::formatString(arg->type,ol,mdef);
-    sem=TRUE;
-    ol.endBold();
-    if (len > 2)
-    {
-      ol.lineBreak();
-      ol.docify("  ");
-    }
-  }//for
-
-  ol.docify(" )");
-
-
-}
-
-/*!
- * writes a function prototype to the output
- */
-
-void VhdlDocGen::writeFunctionProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
-{
-  if (al==0) return;
-  ArgumentListIterator ali(*al);
-  Argument *arg;
-  bool sem=FALSE;
-  int len=al->count();
-  ol.startBold();
-  ol.docify(" ( ");
-  ol.endBold();
-  if (len>2)
-  {
-    ol.lineBreak();
-  }
-  for (;(arg=ali.current());++ali)
-  {
-    ol.startBold();
-    QCString att=arg->defval;
-    bool bGen=att.stripPrefix("gen!");
-
-    if (sem && len < 3)
-    {
-      ol.docify(" , ");
-    }
-
-    if (bGen) {
-      VhdlDocGen::formatString(QCString("generic "),ol,mdef);
-    }
-    if (!att.isEmpty())
-    {
-      QCString *str=VhdlDocGen::findKeyWord(att);
-      att+=" ";
-      if (str)
-        VhdlDocGen::formatString(att,ol,mdef);
-      else
-        VhdlDocGen::startFonts(att,"vhdlchar",ol);
-    }
-
-    QCString nn=arg->name;
-    nn+=": ";
-    QCString ss=arg->type.stripWhiteSpace(); //.lower();
-    QCString w=ss.stripWhiteSpace();//.upper();
-    VhdlDocGen::startFonts(nn,"vhdlchar",ol);
-    VhdlDocGen::startFonts("in ","stringliteral",ol);
-    QCString *str=VhdlDocGen::findKeyWord(ss);
-    if (str)
-      VhdlDocGen::formatString(w,ol,mdef);
-    else
-      VhdlDocGen::startFonts(w,"vhdlchar",ol);
-
-    if (arg->attrib)
-      VhdlDocGen::startFonts(arg->attrib,"vhdlchar",ol);
-
-
-    sem=TRUE;
-    ol.endBold();
-    if (len > 2)
-    {
-      ol.lineBreak();
-    }
-  }
-  ol.startBold();
-  ol.docify(" )");
-  const char *exp=mdef->excpString();
-  if (exp)
-  {
-    ol.insertMemberAlign();
-    ol.startBold();
-    ol.docify("[ ");
-    ol.docify(exp);
-    ol.docify(" ]");
-    ol.endBold();
-  }
-  ol.endBold();
-}
-
-/*!
- * writes a process prototype to the output
- */
-
-void VhdlDocGen::writeProcessProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
-{
-  if (al==0) return;
-  ArgumentListIterator ali(*al);
-  Argument *arg;
-  bool sem=FALSE;
-  ol.startBold();
-  ol.docify(" ( ");
-  for (;(arg=ali.current());++ali)
-  {
-    if (sem)
-    {
-      ol.docify(" , ");
-    }
-    QCString nn=arg->name;
-    // VhdlDocGen::startFonts(nn,"vhdlchar",ol);
-    VhdlDocGen::writeFormatString(nn,ol,mdef);
-    sem=TRUE;
-  }
-  ol.docify(" )");
-  ol.endBold();
-}
-
-
-/*!
- * writes a function|procedure documentation to the output
- */
-
-void VhdlDocGen::writeFuncProcDocu(
-    const MemberDef *md,
-    OutputList& ol,
-    const ArgumentList* al,
-    bool /*type*/)
-{
-  if (al==0) return;
-  //bool sem=FALSE;
-  ol.enableAll();
-
-  ArgumentListIterator ali(*al);
-  int index=ali.count();
-  if (index==0)
-  {
-    ol.docify(" ( ) ");
-    return;
-  }
-  ol.startParameterList(TRUE);
-  //ol.startParameterName(FALSE);
-  Argument *arg;
-  bool first=TRUE;
-  for (;(arg=ali.current());++ali)
-  {
-    ol.startParameterType(first,"");
-    //   if (first) ol.writeChar('(');
-    QCString attl=arg->defval;
-    bool bGen=attl.stripPrefix("gen!");
-    if (bGen)
-      VhdlDocGen::writeFormatString(QCString("generic "),ol,md);
-
-
-    if (VhdlDocGen::isProcedure(md))
-    {
-      startFonts(arg->defval,"keywordtype",ol);
-      ol.docify(" ");
-    }
-    ol.endParameterType();
-
-    ol.startParameterName(TRUE);
-    VhdlDocGen::writeFormatString(arg->name,ol,md);
-    ol.docify(" : ");
-
-    if (VhdlDocGen::isProcedure(md))
-    {
-      startFonts(arg->attrib,"stringliteral",ol);
-    }
-    else if (VhdlDocGen::isVhdlFunction(md))
-    {
-      startFonts(QCString("in"),"stringliteral",ol);
-    }
-
-    ol.docify(" ");
-    ol.disable(OutputGenerator::Man);
-    ol.startEmphasis();
-    ol.enable(OutputGenerator::Man);
-    if (!VhdlDocGen::isProcess(md))
-    {
-     // startFonts(arg->type,"vhdlkeyword",ol);
-		VhdlDocGen::writeFormatString(arg->type,ol,md);
-    }
-    ol.disable(OutputGenerator::Man);
-    ol.endEmphasis();
-    ol.enable(OutputGenerator::Man);
-
-    if (--index)
-    {
-      ol.docify(" , ");
-    }
-    else
-    {
-      //    ol.docify(" ) ");
-      ol.endParameterName(TRUE,FALSE,TRUE);
-      break;
-    }
-    ol.endParameterName(FALSE,FALSE,FALSE);
-
-    //sem=TRUE;
-    first=FALSE;
-  }
-  //ol.endParameterList();
-
-} // writeDocFunProc
-
-
-
-
-QCString VhdlDocGen::convertArgumentListToString(const ArgumentList* al,bool func)
-{
-  QCString argString;
-  bool sem=FALSE;
-  ArgumentListIterator ali(*al);
-  Argument *arg;
-
-  for (;(arg=ali.current());++ali)
-  {
-    if (sem) argString.append(", ");
-    if (func)
-    {
-      argString+=arg->name;
-      argString+=":";
-      argString+=arg->type;
-    }
-    else
-    {
-      argString+=arg->defval+" ";
-      argString+=arg->name+" :";
-      argString+=arg->attrib+" ";
-      argString+=arg->type;
-    }
-    sem=TRUE;
-  }
-  return argString;
-}
-
-
-void VhdlDocGen::writeVhdlDeclarations(MemberList* ml,
-    OutputList& ol,GroupDef* gd,ClassDef* cd,FileDef *fd,NamespaceDef* nd)
-{
-  static ClassDef *cdef;
-  //static GroupDef* gdef;
-  if (cd && cdef!=cd)
-  { // only one inline link
-    VhdlDocGen::writeInlineClassLink(cd,ol);
-    cdef=cd;
-  }
-
-  /*
-     if (gd && gdef==gd) return;
-     if (gd && gdef!=gd)
-     {
-     gdef=gd;
-     }
-   */
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::LIBRARY,FALSE),0,FALSE,VhdlDocGen::LIBRARY);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::USE,FALSE),0,FALSE,VhdlDocGen::USE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::FUNCTION,FALSE),0,FALSE,VhdlDocGen::FUNCTION);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::COMPONENT,FALSE),0,FALSE,VhdlDocGen::COMPONENT);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::CONSTANT,FALSE),0,FALSE,VhdlDocGen::CONSTANT);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::TYPE,FALSE),0,FALSE,VhdlDocGen::TYPE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SUBTYPE,FALSE),0,FALSE,VhdlDocGen::SUBTYPE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::GENERIC,FALSE),0,FALSE,VhdlDocGen::GENERIC);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PORT,FALSE),0,FALSE,VhdlDocGen::PORT);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PROCESS,FALSE),0,FALSE,VhdlDocGen::PROCESS);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SIGNAL,FALSE),0,FALSE,VhdlDocGen::SIGNAL);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::ATTRIBUTE,FALSE),0,FALSE,VhdlDocGen::ATTRIBUTE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PROCEDURE,FALSE),0,FALSE,VhdlDocGen::PROCEDURE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::RECORD,FALSE),0,FALSE,VhdlDocGen::RECORD);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::UNITS,FALSE),0,FALSE,VhdlDocGen::UNITS);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SHAREDVARIABLE,FALSE),0,FALSE,VhdlDocGen::SHAREDVARIABLE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::VFILE,FALSE),0,FALSE,VhdlDocGen::VFILE);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::GROUP,FALSE),0,FALSE,VhdlDocGen::GROUP);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::INSTANTIATION,FALSE),0,FALSE,VhdlDocGen::INSTANTIATION);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::ALIAS,FALSE),0,FALSE,VhdlDocGen::ALIAS);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::MISCELLANEOUS),0,FALSE,VhdlDocGen::MISCELLANEOUS);
-
-  // configurations must be added to global file definitions.
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::CONFIG,FALSE),0,FALSE,VhdlDocGen::CONFIG);
-  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::UCF_CONST,FALSE),0,FALSE,VhdlDocGen::UCF_CONST);
-
-}
-
-static void setGlobalType(MemberList *ml)
-{
-  if (ml==0) return;
-  MemberDef *mdd=0;
-  MemberListIterator mmli(*ml);
-  for ( ; (mdd=mmli.current()); ++mmli )
-  {
-    QCString l=mdd->typeString();
-
-    if (strcmp(mdd->argsString(),"package")==0)
-    {
- 	mdd->setMemberSpecifiers(VhdlDocGen::INSTANTIATION);
-    }
-    else if (strcmp(mdd->argsString(),"configuration")==0)
-    {
-      mdd->setMemberSpecifiers(VhdlDocGen::CONFIG);
-    }
-    else if (strcmp(mdd->typeString(),"library")==0)
-    {
-      mdd->setMemberSpecifiers(VhdlDocGen::LIBRARY);
-    }
-    else if (strcmp(mdd->typeString(),"use")==0)
-    {
-      mdd->setMemberSpecifiers(VhdlDocGen::USE);
-    }
-    else if (stricmp(mdd->typeString(),"misc")==0)
-    {
-      mdd->setMemberSpecifiers(VhdlDocGen::MISCELLANEOUS);
-    }
-    else if (stricmp(mdd->typeString(),"ucf_const")==0)
-    {
-      mdd->setMemberSpecifiers(VhdlDocGen::UCF_CONST);
-    }
-  }
-}
-
-/* writes a vhdl type documentation */
-void VhdlDocGen::writeVHDLTypeDocumentation(const MemberDef* mdef, const Definition *d, OutputList &ol)
-{
-  ClassDef *cd=(ClassDef*)d;
-
-  if (cd==0) return;
-
-  QCString ttype=mdef->typeString();
-  QCString largs=mdef->argsString();
-
-  if ((VhdlDocGen::isVhdlFunction(mdef) || VhdlDocGen::isProcedure(mdef) || VhdlDocGen::isProcess(mdef)))
-  {
-    QCString nn=mdef->typeString();
-    nn=nn.stripWhiteSpace();
-    QCString na=cd->name();
-    MemberDef* memdef=VhdlDocGen::findMember(na,nn);
-    if (memdef && memdef->isLinkable())
-    {
-      ol.docify(" ");
-
-      ol.startBold();
-      writeLink(memdef,ol);
-      ol.endBold();
-      ol.docify(" ");
-    }
-    else
-    {
-      ol.docify(" ");
-      VhdlDocGen::formatString(ttype,ol,mdef);
-      ol.docify(" ");
-    }
-    ol.docify(mdef->name());
-    VhdlDocGen::writeFuncProcDocu(mdef,ol, mdef->argumentList().pointer());
-  }
-
-
-  if (mdef->isVariable())
-  {
-    if (VhdlDocGen::isConstraint(mdef))
-    {
-      writeLink(mdef,ol);
-      ol.docify(" ");
-
-      largs=largs.replace(QRegExp("#")," ");
-      VhdlDocGen::formatString(largs,ol,mdef);
-      return;
-    }
-    else
-    {
-      writeLink(mdef,ol);
-      if (VhdlDocGen::isLibrary(mdef) || VhdlDocGen::isPackage(mdef))
-      {
-        return;
-      }
-      ol.docify(" ");
-    }
-
-    // QCString largs=mdef->argsString();
-
-    bool c=largs=="context";
-    bool brec=largs.stripPrefix("record")  ;
-
-    if (!brec && !c)
-      VhdlDocGen::formatString(ttype,ol,mdef);
-
-    if (c || brec || largs.stripPrefix("units"))
-    {
-      if (c)
-	  largs=ttype;
-      VhdlDocGen::writeRecUnitDocu(mdef,ol,largs);
-      return;
-    }
-
-    ol.docify(" ");
-    if (VhdlDocGen::isPort(mdef) || VhdlDocGen::isGeneric(mdef))
-    {
-      // QCString largs=mdef->argsString();
-      VhdlDocGen::formatString(largs,ol,mdef);
-      ol.docify(" ");
-    }
-  }
-}
-
-/* writes a vhdl type declaration */
-
-void VhdlDocGen::writeVHDLDeclaration(MemberDef* mdef,OutputList &ol,
-    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
-    bool /*inGroup*/)
-{
-  static QRegExp reg("[%]");
-  LockingPtr<MemberDef> lock(mdef,mdef);
-
-  Definition *d=0;
-
-  /* some vhdl files contain only a configuration  description
-
-     library work;
-     configuration cfg_tb_jtag_gotoBackup of tb_jtag_gotoBackup is
-     for RTL
-     end for;
-     end cfg_tb_jtag_gotoBackup;
-
-     in this case library work does not belong to an entity, package ...
-
-   */
-
-  ASSERT(cd!=0 || nd!=0 || fd!=0 || gd!=0 ||
-      mdef->getMemberSpecifiers()==VhdlDocGen::LIBRARY ||
-      mdef->getMemberSpecifiers()==VhdlDocGen::USE
-      ); // member should belong to something
-  if (cd) d=cd;
-  else if (nd) d=nd;
-  else if (fd) d=fd;
-  else if (gd) d=gd;
-  else d=(Definition*)mdef;
-
-  // write tag file information of this member
-  if (!Config_getString("GENERATE_TAGFILE").isEmpty())
-  {
-    Doxygen::tagFile << "    <member kind=\"";
-    if (VhdlDocGen::isGeneric(mdef))      Doxygen::tagFile << "generic";
-    if (VhdlDocGen::isPort(mdef))         Doxygen::tagFile << "port";
-    if (VhdlDocGen::isEntity(mdef))       Doxygen::tagFile << "entity";
-    if (VhdlDocGen::isComponent(mdef))    Doxygen::tagFile << "component";
-    if (VhdlDocGen::isVType(mdef))        Doxygen::tagFile << "type";
-    if (VhdlDocGen::isConstant(mdef))     Doxygen::tagFile << "constant";
-    if (VhdlDocGen::isSubType(mdef))      Doxygen::tagFile << "subtype";
-    if (VhdlDocGen::isVhdlFunction(mdef)) Doxygen::tagFile << "function";
-    if (VhdlDocGen::isProcedure(mdef))    Doxygen::tagFile << "procedure";
-    if (VhdlDocGen::isProcess(mdef))      Doxygen::tagFile << "process";
-    if (VhdlDocGen::isSignals(mdef))      Doxygen::tagFile << "signal";
-    if (VhdlDocGen::isAttribute(mdef))    Doxygen::tagFile << "attribute";
-    if (VhdlDocGen::isRecord(mdef))       Doxygen::tagFile << "record";
-    if (VhdlDocGen::isLibrary(mdef))      Doxygen::tagFile << "library";
-    if (VhdlDocGen::isPackage(mdef))      Doxygen::tagFile << "package";
-    if (VhdlDocGen::isVariable(mdef))     Doxygen::tagFile << "shared variable";
-    if (VhdlDocGen::isFile(mdef))         Doxygen::tagFile << "file";
-    if (VhdlDocGen::isGroup(mdef))        Doxygen::tagFile << "group";
-    if (VhdlDocGen::isCompInst(mdef))     Doxygen::tagFile << " instantiation";
-    if (VhdlDocGen::isAlias(mdef))        Doxygen::tagFile << "alias";
-    if (VhdlDocGen::isCompInst(mdef))     Doxygen::tagFile << "configuration";
-
-    Doxygen::tagFile << "\">" << endl;
-    Doxygen::tagFile << "      <type>" << convertToXML(mdef->typeString()) << "</type>" << endl;
-    Doxygen::tagFile << "      <name>" << convertToXML(mdef->name()) << "</name>" << endl;
-    Doxygen::tagFile << "      <anchorfile>" << convertToXML(mdef->getOutputFileBase()+Doxygen::htmlFileExtension) << "</anchorfile>" << endl;
-    Doxygen::tagFile << "      <anchor>" << convertToXML(mdef->anchor()) << "</anchor>" << endl;
-
-    if (VhdlDocGen::isVhdlFunction(mdef))
-      Doxygen::tagFile << "      <arglist>" << convertToXML(VhdlDocGen::convertArgumentListToString(mdef->argumentList().pointer(),TRUE)) << "</arglist>" << endl;
-    else if (VhdlDocGen::isProcedure(mdef))
-      Doxygen::tagFile << "      <arglist>" << convertToXML(VhdlDocGen::convertArgumentListToString(mdef->argumentList().pointer(),FALSE)) << "</arglist>" << endl;
-    else
-      Doxygen::tagFile << "      <arglist>" << convertToXML(mdef->argsString()) << "</arglist>" << endl;
-
-    mdef->writeDocAnchorsToTagFile();
-    Doxygen::tagFile << "    </member>" << endl;
-
-  }
-
-  // write search index info
-  if (Doxygen::searchIndex)
-  {
-    Doxygen::searchIndex->setCurrentDoc(mdef->qualifiedName(),mdef->getOutputFileBase(),mdef->anchor());
-    Doxygen::searchIndex->addWord(mdef->localName(),TRUE);
-    Doxygen::searchIndex->addWord(mdef->qualifiedName(),FALSE);
-  }
-
-  QCString cname  = d->name();
-  QCString cfname = d->getOutputFileBase();
-
-  //HtmlHelp *htmlHelp=0;
-  //  bool hasHtmlHelp = Config_getBool("GENERATE_HTML") && Config_getBool("GENERATE_HTMLHELP");
-  //  if (hasHtmlHelp) htmlHelp = HtmlHelp::getInstance();
-
-  // search for the last anonymous scope in the member type
-  ClassDef *annoClassDef=mdef->getClassDefOfAnonymousType();
-
-  // start a new member declaration
-  bool isAnonymous = annoClassDef; // || m_impl->annMemb || m_impl->annEnumType;
-  ///printf("startMemberItem for %s\n",name().data());
-  ol.startMemberItem( mdef->anchor(), isAnonymous ); //? 1 : m_impl->tArgList ? 3 : 0);
-
-  // If there is no detailed description we need to write the anchor here.
-  bool detailsVisible = mdef->isDetailedSectionLinkable();
-  if (!detailsVisible) // && !m_impl->annMemb)
-  {
-    QCString doxyName=mdef->name().copy();
-    if (!cname.isEmpty()) doxyName.prepend(cname+"::");
-    QCString doxyArgs=mdef->argsString();
-    ol.startDoxyAnchor(cfname,cname,mdef->anchor(),doxyName,doxyArgs);
-
-    ol.pushGeneratorState();
-    ol.disable(OutputGenerator::Man);
-    ol.disable(OutputGenerator::Latex);
-    ol.docify("\n");
-    ol.popGeneratorState();
-
-  }
-  // *** write type
-  /*VHDL CHANGE */
-  bool bRec,bUnit;
-  QCString ltype(mdef->typeString());
-  ltype=ltype.replace(reg," ");
-  QCString largs(mdef->argsString());
-  largs=largs.replace(reg," ");
-  int mm=mdef->getMemberSpecifiers();
-  mdef->setType(ltype.data());
-  mdef->setArgsString(largs.data());
-  //ClassDef * plo=mdef->getClassDef();
-  ClassDef *kl=0;
-  LockingPtr<ArgumentList> alp = mdef->argumentList();
-  QCString nn;
-  //VhdlDocGen::adjustRecordMember(mdef);
-  if (gd) gd=0;
-  switch(mm)
-  {
-    case VhdlDocGen::MISCELLANEOUS:
-      VhdlDocGen::writeCodeFragment(mdef,ol);
-      break;
-    case VhdlDocGen::PROCEDURE:
-    case VhdlDocGen::FUNCTION:
-      ol.startBold();
-      VhdlDocGen::formatString(ltype,ol,mdef);
-      ol.endBold();
-      ol.insertMemberAlign();
-      ol.docify(" ");
-
-      writeLink(mdef,ol);
-      if (alp!=0 && mm==VhdlDocGen::FUNCTION)
-        VhdlDocGen::writeFunctionProto(ol,alp.pointer(),mdef);
-
-      if (alp!=0 && mm==VhdlDocGen::PROCEDURE)
-        VhdlDocGen::writeProcedureProto(ol,alp.pointer(),mdef);
-
-      break;
-    case VhdlDocGen::USE:
-      kl=VhdlDocGen::getClass(mdef->name());
-      if (kl && ((VhdlDocGen::VhdlClasses)kl->protection()==VhdlDocGen::ENTITYCLASS)) break;
-      writeLink(mdef,ol);
-      ol.insertMemberAlign();
-      ol.docify("  ");
-
-      if (kl)
-      {
-        nn=kl->getOutputFileBase();
-        ol.pushGeneratorState();
-        ol.disableAllBut(OutputGenerator::Html);
-        ol.docify(" ");
-        QCString name=theTranslator_vhdlType(VhdlDocGen::PACKAGE,TRUE);
-        ol.startBold();
-        ol.docify(name.data());
-        name.resize(0);
-        ol.endBold();
-        name+=" <"+mdef->name()+">";
-        ol.startEmphasis();
-        ol.writeObjectLink(kl->getReference(),kl->getOutputFileBase(),0,name.data());
-        ol.popGeneratorState();
-      }
-      break;
-    case VhdlDocGen::LIBRARY:
-      writeLink(mdef,ol);
-      ol.insertMemberAlign();
-     if (largs=="context")
-     {
-	VhdlDocGen::writeRecorUnit(ltype,ol,mdef);
-     }
-
-     break;
-
-    case VhdlDocGen::GENERIC:
-    case VhdlDocGen::PORT:
-    case VhdlDocGen::ALIAS:
-
-      writeLink(mdef,ol);
-      ol.docify(" ");
-      ol.insertMemberAlign();
-      if (mm==VhdlDocGen::GENERIC)
-      {
-        ol.startBold();
-        VhdlDocGen::formatString(largs,ol,mdef);
-        ol.endBold();
-      }
-      else
-      {
-        ol.docify(" ");
-        ol.startBold();
-        VhdlDocGen::formatString(ltype,ol,mdef);
-        ol.endBold();
-        ol.docify(" ");
-        VhdlDocGen::formatString(largs,ol,mdef);
-      }
-      break;
-    case VhdlDocGen::PROCESS:
-      writeLink(mdef,ol);
-      ol.insertMemberAlign();
-      VhdlDocGen::writeProcessProto(ol,alp.pointer(),mdef);
-      break;
-    case VhdlDocGen::PACKAGE:
-    case VhdlDocGen::ENTITY:
-    case VhdlDocGen::COMPONENT:
-    case VhdlDocGen::INSTANTIATION:
-    case VhdlDocGen::CONFIG:
-      if (VhdlDocGen::isCompInst(mdef) )
-      {
-        nn=largs;
-        if(nn.stripPrefix("function") || nn.stripPrefix("package"))
-        {
-          VhdlDocGen::formatString(largs,ol,mdef);
-          ol.insertMemberAlign();
-          writeLink(mdef,ol);
-          ol.docify(" ");
-          VhdlDocGen::formatString(ltype,ol,mdef);
-          break;
-        }
-
-        largs.prepend("::");
-        largs.prepend(mdef->name().data());
-        ol.writeObjectLink(mdef->getReference(),
-            cfname,
-            mdef->anchor(),
-            mdef->name());
-      }
-      else
-        writeLink(mdef,ol);
-
-      ol.insertMemberAlign();
-      ol.docify("  ");
-
-      ol.startBold();
-      ol.docify(ltype);
-      ol.endBold();
-      ol.docify("  ");
-      if (VhdlDocGen::isComponent(mdef) ||
-          VhdlDocGen::isConfig(mdef)    ||
-          VhdlDocGen::isCompInst(mdef))
-      {
-        if (VhdlDocGen::isConfig(mdef) || VhdlDocGen::isCompInst(mdef))
-        {
-          nn=mdef->getOutputFileBase();
-          nn=ltype;
-        }
-        else
-        {
-          nn=mdef->name();
-        }
-        kl=getClass(nn.data());
-        if (kl)
-        {
-          nn=kl->getOutputFileBase();
-          ol.pushGeneratorState();
-          ol.disableAllBut(OutputGenerator::Html);
-          ol.startEmphasis();
-          QCString name("<Entity ");
-          if (VhdlDocGen::isConfig(mdef) || VhdlDocGen::isCompInst(mdef))
-          {
-            name+=ltype+">";
-          }
-          else
-          {
-            name+=mdef->name()+"> ";
-          }
-          ol.writeObjectLink(kl->getReference(),kl->getOutputFileBase(),0,name.data());
-          ol.endEmphasis();
-          ol.popGeneratorState();
-        }
-      }
-      break;
-    case VhdlDocGen::UCF_CONST:
-      mm=mdef->name().findRev('_');
-      if (mm>0)
-      {
-        mdef->setName(mdef->name().left(mm));
-      }
-      writeUCFLink(mdef,ol);
-      break;
-    case VhdlDocGen::SIGNAL:
-    case VhdlDocGen::ATTRIBUTE:
-    case VhdlDocGen::SUBTYPE:
-    case VhdlDocGen::CONSTANT:
-    case VhdlDocGen::SHAREDVARIABLE:
-    case VhdlDocGen::VFILE:
-    case VhdlDocGen::GROUP:
-      writeLink(mdef,ol);
-      ol.docify(" ");
-      ol.insertMemberAlign();
-      VhdlDocGen::formatString(ltype,ol,mdef);
-      break;
-    case VhdlDocGen::TYPE:
-      bRec=largs.stripPrefix("record") ;
-      bUnit=largs.stripPrefix("units") ;
-      ol.startBold();
-      if (bRec)
-        ol.docify("record: ");
-      if (bUnit)
-        ol.docify("units: ");
-      writeLink(mdef,ol);
-      ol.insertMemberAlign();
-      if (!bRec)
-        VhdlDocGen::formatString(ltype,ol,mdef);
-      if (bUnit) ol.lineBreak();
-      if (bRec || bUnit)
-        writeRecorUnit(largs,ol,mdef);
-      ol.endBold();
-      break;
-
-    default: break;
-  }
-
-  bool htmlOn = ol.isEnabled(OutputGenerator::Html);
-  if (htmlOn && /*Config_getBool("HTML_ALIGN_MEMBERS") &&*/ !ltype.isEmpty())
-  {
-    ol.disable(OutputGenerator::Html);
-  }
-  if (!ltype.isEmpty()) ol.docify(" ");
-
-  if (htmlOn)
-  {
-    ol.enable(OutputGenerator::Html);
-  }
-
-  if (!detailsVisible)// && !m_impl->annMemb)
-  {
-    ol.endDoxyAnchor(cfname,mdef->anchor());
-  }
-
-  //printf("endMember %s annoClassDef=%p annEnumType=%p\n",
-  //    name().data(),annoClassDef,annEnumType);
-  ol.endMemberItem();
-  if (!mdef->briefDescription().isEmpty() &&   Config_getBool("BRIEF_MEMBER_DESC") /* && !annMemb */)
-  {
-    ol.startMemberDescription(mdef->anchor());
-    ol.parseDoc(mdef->briefFile(),mdef->briefLine(),
-        mdef->getOuterScope()?mdef->getOuterScope():d,
-        mdef,mdef->briefDescription(),TRUE,FALSE,0,TRUE,FALSE);
-    if (detailsVisible)
-    {
-      ol.pushGeneratorState();
-      ol.disableAllBut(OutputGenerator::Html);
-      //ol.endEmphasis();
-      ol.docify(" ");
-      if (mdef->getGroupDef()!=0 && gd==0) // forward link to the group
-      {
-        ol.startTextLink(mdef->getOutputFileBase(),mdef->anchor());
-      }
-      else // local link
-      {
-        ol.startTextLink(0,mdef->anchor());
-      }
-      ol.endTextLink();
-      //ol.startEmphasis();
-      ol.popGeneratorState();
-    }
-    //ol.newParagraph();
-    ol.endMemberDescription();
-  }
-  mdef->warnIfUndocumented();
-
-}// end writeVhdlDeclaration
-
-
-void VhdlDocGen::writeLink(const MemberDef* mdef,OutputList &ol)
-{
-  ol.writeObjectLink(mdef->getReference(),
-      mdef->getOutputFileBase(),
-      mdef->anchor(),
-      mdef->name());
-}
-
-void VhdlDocGen::writePlainVHDLDeclarations(
-    MemberList* mlist,OutputList &ol,
-    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,int specifier)
-{
-
-  SDict<QCString> pack(1009);
-
-  ol.pushGeneratorState();
-
-  bool first=TRUE;
-  MemberDef *md;
-  MemberListIterator mli(*mlist);
-  for ( ; (md=mli.current()); ++mli )
-  {
-    int mems=md->getMemberSpecifiers();
-    if (md->isBriefSectionVisible() && (mems==specifier) && (mems!=VhdlDocGen::LIBRARY) )
-    {
-      if (first) {ol.startMemberList();first=FALSE;}
-      VhdlDocGen::writeVHDLDeclaration(md,ol,cd,nd,fd,gd,FALSE);
-    } //if
-    else if (md->isBriefSectionVisible() && (mems==specifier))
-    {
-      if (!pack.find(md->name().data()))
-      {
-        if (first) ol.startMemberList(),first=FALSE;
-        VhdlDocGen::writeVHDLDeclaration(md,ol,cd,nd,fd,gd,FALSE);
-        pack.append(md->name().data(),new QCString(md->name().data()));
-      }
-    } //if
-  } //for
-  if (!first) ol.endMemberList();
-  pack.clear();
-}//plainDeclaration
-
-bool VhdlDocGen::membersHaveSpecificType(MemberList *ml,int type)
-{
-  if (ml==0) return FALSE;
-  MemberDef *mdd=0;
-  MemberListIterator mmli(*ml);
-  for ( ; (mdd=mmli.current()); ++mmli )
-  {
-    if (mdd->getMemberSpecifiers()==type) //is type in class
-    {
-      return TRUE;
-    }
-  }
-  if (ml->getMemberGroupList())
-  {
-    MemberGroupListIterator mgli(*ml->getMemberGroupList());
-    MemberGroup *mg;
-    while ((mg=mgli.current()))
-    {
-      if (mg->members())
-      {
-        if (membersHaveSpecificType(mg->members(),type)) return TRUE;
-      }
-      ++mgli;
-    }
-  }
-  return FALSE;
-}
-
-void VhdlDocGen::writeVHDLDeclarations(MemberList* ml,OutputList &ol,
-    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
-    const char *title,const char *subtitle,bool /*showEnumValues*/,int type)
-{
-  setGlobalType(ml);
-  if (!membersHaveSpecificType(ml,type)) return;
-
-  if (title)
-  {
-    ol.startMemberHeader(title);
-    ol.parseText(title);
-    ol.endMemberHeader();
-    ol.docify(" ");
-  }
-  if (subtitle && subtitle[0]!=0)
-  {
-    ol.startMemberSubtitle();
-    ol.parseDoc("[generated]",-1,0,0,subtitle,FALSE,FALSE,0,TRUE,FALSE);
-    ol.endMemberSubtitle();
-  } //printf("memberGroupList=%p\n",memberGroupList);
-
-  VhdlDocGen::writePlainVHDLDeclarations(ml,ol,cd,nd,fd,gd,type);
-
-  if (ml->getMemberGroupList())
-  {
-    MemberGroupListIterator mgli(*ml->getMemberGroupList());
-    MemberGroup *mg;
-    while ((mg=mgli.current()))
-    {
-      if (membersHaveSpecificType(mg->members(),type))
-      {
-        //printf("mg->header=%s\n",mg->header().data());
-        bool hasHeader=mg->header()!="[NOHEADER]";
-        ol.startMemberGroupHeader(hasHeader);
-        if (hasHeader)
-        {
-          ol.parseText(mg->header());
-        }
-        ol.endMemberGroupHeader();
-        if (!mg->documentation().isEmpty())
-        {
-          //printf("Member group has docs!\n");
-          ol.startMemberGroupDocs();
-          ol.parseDoc("[generated]",-1,0,0,mg->documentation()+"\n",FALSE,FALSE);
-          ol.endMemberGroupDocs();
-        }
-        ol.startMemberGroup();
-        //printf("--- mg->writePlainDeclarations ---\n");
-        VhdlDocGen::writePlainVHDLDeclarations(mg->members(),ol,cd,nd,fd,gd,type);
-        ol.endMemberGroup(hasHeader);
-      }
-      ++mgli;
-    }
-  }
-}// writeVHDLDeclarations
-
-#if 0
-/* strips the prefix for record and unit members*/
-void VhdlDocGen::adjustRecordMember(MemberDef *mdef)
-{ //,OutputList & ol) {
-  QRegExp regg("[_a-zA-Z\"]");
-  QCString nn=mdef->name();
-  int j=nn.find(regg,0);
-  if (j>0)
-  {
-    nn=nn.mid(j,nn.length());
-    mdef->setName(nn.data());
-  }
-}//adjustRecordMember
-#endif
-/* strips the prefix for package and package body */
-
-bool VhdlDocGen::writeClassType( ClassDef *& cd,
-    OutputList &ol ,QCString & cname)
-{
-  //static ClassDef *prev = 0;
-  //if (prev == cd)  return TRUE;
-  //if (cd != prev) prev=cd;
-
-  int id=cd->protection();
-  QCString qcs = VhdlDocGen::trTypeString(id+2);
-  cname=VhdlDocGen::getClassName(cd);
-  ol.startBold();
-  ol.writeString(qcs.data());
-  ol.writeString(" ");
-  ol.endBold();
-  //ol.insertMemberAlign();
-  return FALSE;
-}// writeClassLink
-
-QCString VhdlDocGen::trVhdlType(int type,bool sing)
-{
-  switch(type)
-  {
-    case VhdlDocGen::LIBRARY:
-      if (sing) return "Library";
-      else      return "Libraries";
-    case VhdlDocGen::PACKAGE:
-      if (sing) return "Package";
-      else      return "Packages";
-    case VhdlDocGen::SIGNAL:
-      if (sing) return "Signal";
-      else      return "Signals";
-    case VhdlDocGen::COMPONENT:
-      if (sing) return "Component";
-      else      return "Components";
-    case VhdlDocGen::CONSTANT:
-      if (sing) return "Constant";
-      else      return "Constants";
-    case VhdlDocGen::ENTITY:
-      if (sing) return "Entity";
-      else      return "Entities";
-    case VhdlDocGen::TYPE:
-      if (sing) return "Type";
-      else      return "Types";
-    case VhdlDocGen::SUBTYPE:
-      if (sing) return "Subtype";
-      else      return "Subtypes";
-    case VhdlDocGen::FUNCTION:
-      if (sing) return "Function";
-      else      return "Functions";
-    case VhdlDocGen::RECORD:
-      if (sing) return "Record";
-      else      return "Records";
-    case VhdlDocGen::PROCEDURE:
-      if (sing) return "Procedure";
-      else      return "Procedures";
-    case VhdlDocGen::ARCHITECTURE:
-      if (sing) return "Architecture";
-      else      return "Architectures";
-    case VhdlDocGen::ATTRIBUTE:
-      if (sing) return "Attribute";
-      else      return "Attributes";
-    case VhdlDocGen::PROCESS:
-      if (sing) return "Process";
-      else      return "Processes";
-    case VhdlDocGen::PORT:
-      if (sing) return "Port";
-      else      return "Ports";
-    case VhdlDocGen::USE:
-      if (sing) return "use clause";
-      else      return "Use Clauses";
-    case VhdlDocGen::GENERIC:
-      if (sing) return "Generic";
-      else      return "Generics";
-    case VhdlDocGen::PACKAGE_BODY:
-      return "Package Body";
-    case VhdlDocGen::UNITS:
-      return "Units";
-    case VhdlDocGen::SHAREDVARIABLE:
-      if (sing) return "Shared Variable";
-      return "Shared Variables";
-    case VhdlDocGen::VFILE:
-      if (sing) return "File";
-      return "Files";
-    case VhdlDocGen::GROUP:
-      if (sing) return "Group";
-      return "Groups";
-    case VhdlDocGen::INSTANTIATION:
-      if (sing) return "Instantiation";
-      else      return "Instantiations";
-    case VhdlDocGen::ALIAS:
-      if (sing) return "Alias";
-      return "Aliases";
-    case VhdlDocGen::CONFIG:
-      if (sing) return "Configuration";
-      return "Configurations";
-    case VhdlDocGen::MISCELLANEOUS:
-      return "Miscellaneous";
-    case VhdlDocGen::UCF_CONST:
-      return "Constraints";
-    default:
-      return "Class";
-  }
-}
-
-QCString VhdlDocGen::trDesignUnitHierarchy()
-{
-  return "Design Unit Hierarchy";
-}
-
-QCString VhdlDocGen::trDesignUnitList()
-{
-  return "Design Unit List";
-}
-
-QCString VhdlDocGen::trDesignUnitMembers()
-{
-  return "Design Unit Members";
-}
-
-QCString VhdlDocGen::trDesignUnitListDescription()
-{
-  return "Here is a list of all design unit members with links to "
-    "the Entities  they belong to:";
-}
-
-QCString VhdlDocGen::trDesignUnitIndex()
-{
-  return "Design Unit Index";
-}
-
-QCString VhdlDocGen::trDesignUnits()
-{
-  return "Design Units";
-}
-
-QCString VhdlDocGen::trFunctionAndProc()
-{
-  return "Functions/Procedures/Processes";
-}
-
-
-
-
-
-/* do not insert the same component twice */
-
-bool VhdlDocGen::foundInsertedComponent(const QCString & name,Entry* root)
-{
-  QListIterator<BaseInfo> bii(*root->extends);
-  BaseInfo *bi=0;
-  for (bii.toFirst();(bi=bii.current());++bii)
-  {
-    if (bi->name==name)
-    {
-      return TRUE; //
-    }
-  }
-
-  return FALSE;
-}// found component
-
-/*! writes a link if the string is linkable else a formatted string */
-
-void VhdlDocGen::writeStringLink(const MemberDef *mdef,QCString mem, OutputList& ol)
-{
-  if (mdef)
-  {
-    ClassDef *cd=mdef->getClassDef();
-    if (cd)
-    {
-      QCString n=cd->name();
-      MemberDef* memdef=VhdlDocGen::findMember(n,mem);
-      if (memdef && memdef->isLinkable())
-      {
-        ol.startBold();
-        writeLink(memdef,ol);
-        ol.endBold();
-        ol.docify(" ");
-        return;
-      }
-    }
-  }
-  VhdlDocGen::startFonts(mem,"vhdlchar",ol);
-}// found component
-
-void VhdlDocGen::writeCodeFragment( MemberDef *mdef,OutputList& ol)
-{
-  //  Definition d=(Definition)mdef;
-  //	QCString fdd=mdef->getDefFileExtension();
-  //	QCString scope=mdef->getScopeString();
-  QCString codeFragment=mdef->documentation();
-  //FileDef *fd=mdef->getFileDef();
-
-  //int start=mdef->getStartBodyLine();
-  //int end=mdef->getEndBodyLine();
-  QStringList qsl=QStringList::split("\n",codeFragment);
-  writeLink(mdef,ol);
-  ol.docify(" ");
-  ol.insertMemberAlign();
-  int len= qsl.count();
-  for(int j=0;j<len;j++)
-  {
-    QCString q=qsl[j].utf8();
-    VhdlDocGen::writeFormatString(q,ol,mdef);
-    ol.lineBreak();
-    if (j==2) // only the first three lines are shown
-    {
-      q = "...";
-      VhdlDocGen::writeFormatString(q,ol,mdef);
-      break;
-    }
-  }
-}
-
-void VhdlDocGen::writeSource(MemberDef *mdef,OutputList& ol,QCString & cname)
-{
-  QCString codeFragment=mdef->documentation();
-  int start=mdef->getStartBodyLine();
-  QStringList qsl=QStringList::split("\n",codeFragment);
-  ol.startCodeFragment();
-  int len = qsl.count();
-  QCString lineNumber;
-  int j;
-  for (j=0;j<len;j++)
-  {
-    lineNumber.sprintf("%05d",start++);
-    lineNumber+=" ";
-    ol.startBold();
-    ol.docify(lineNumber.data());
-    ol.endBold();
-    ol.insertMemberAlign();
-    QCString q=qsl[j].utf8();
-    VhdlDocGen::writeFormatString(q,ol,mdef);
-    ol.docify("\n");
-  }
-  ol.endCodeFragment();
-
-  mdef->writeSourceDef(ol,cname);
-  mdef->writeSourceRefs(ol,cname);
-  mdef->writeSourceReffedBy(ol,cname);
-}
-
-
-QCString VhdlDocGen::convertFileNameToClassName(QCString name)
-{
-
-  QCString n=name;
-  n=n.remove(0,6);
-
-  int i=0;
-
-  while((i=n.find("__"))>0)
-  {
-    n=n.remove(i,1);
-  }
-
-  while((i=n.find("_1"))>0)
-  {
-    n=n.replace(i,2,":");
-  }
-
-  return n;
-}
-
-void VhdlDocGen::parseUCF(const char*  input,  Entry* entity,QCString fileName,bool altera)
-{
-  QCString ucFile(input);
-  int lineNo=0;
-  QCString newLine="\n";
-  QCString comment("#!");
-  QCString brief;
-
-  while(!ucFile.isEmpty())
-  {
-    int i=ucFile.find("\n");
-    if (i<0) break;
-    lineNo++;
-    QCString temp=ucFile.left(i);
-    temp=temp.stripWhiteSpace();
-    bool bb=temp.stripPrefix("//");
-
-    if (!temp.isEmpty())
-    {
-      if (temp.stripPrefix(comment) )
-      {
-        brief+=temp;
-        brief.append("\\n");
-      }
-      else if (!temp.stripPrefix("#") && !bb)
-      {
-        if (altera)
-        {
-          int i=temp.find("-name");
-          if (i>0)
-            temp=temp.remove(0,i+5);
-
-          temp.stripPrefix("set_location_assignment");
-
-          initUCF(entity,0,temp,lineNo,fileName,brief);
-        }
-        else
-        {
-          QRegExp ee("[\\s=]");
-          int i=temp.find(ee);
-          QCString ff=temp.left(i);
-          temp.stripPrefix(ff.data());
-          ff.append("#");
-          if (!temp.isEmpty())
-          {
-            initUCF(entity,ff.data(),temp,lineNo,fileName,brief);
-          }
-        }
-      }
-    }//temp
-
-    ucFile=ucFile.remove(0,i+1);
-  }// while
-}
-
-static void initUCF(Entry* root,const char*  type,QCString &  qcs,int line,QCString & fileName,QCString & brief)
-{
-  if (qcs.isEmpty())return;
-  QRegExp sp("\\s");
-  QRegExp reg("[\\s=]");
-  QCString n;
-  // bool bo=(stricmp(type,qcs.data())==0);
-
-  VhdlDocGen::deleteAllChars(qcs,';');
-  qcs=qcs.stripWhiteSpace();
-
-  int i= qcs.find(reg);
-  if (i<0) return;
-  if (i==0)
-  {
-    n=type;
-    VhdlDocGen::deleteAllChars(n,'#');
-    type="";
-  }
-  else
-  {
-    n=qcs.left(i);
-  }
-  qcs=qcs.remove(0,i+1);
-  //  qcs.prepend("|");
-
-  qcs.stripPrefix("=");
-
-  Entry* current=new Entry;
-  current->spec=VhdlDocGen::UCF_CONST;
-  current->section=Entry::VARIABLE_SEC;
-  current->bodyLine=line;
-  current->fileName=fileName;
-  current->type="ucf_const";
-  //if (!bo)
-  //current->args=type;
-  current->args+=qcs;
-  current->lang=  SrcLangExt_VHDL ;
-
-  // adding dummy name for constraints like VOLTAGE=5,TEMPERATURE=20 C
-  if (n.isEmpty())
-  {
-    n="dummy";
-    n+=VhdlDocGen::getRecordNumber();
-  }
-
-  current->name= n+"_";
-  current->name.append(VhdlDocGen::getRecordNumber().data());
-
-  if (!brief.isEmpty())
-  {
-    current->brief=brief;
-    current->briefLine=line;
-    current->briefFile=fileName;
-    brief.resize(0);
-  }
-
-  root->addSubEntry(current);
-}
-
-
-static void writeUCFLink(const MemberDef* mdef,OutputList &ol)
-{
-
-  QCString largs(mdef->argsString());
-  QCString n= VhdlDocGen::splitString(largs, '#');
-  // VhdlDocGen::adjustRecordMember(mdef);
-  bool equ=(n.length()==largs.length());
-
-  if (!equ)
-  {
-    ol.writeString(n.data());
-    ol.docify(" ");
-    ol.insertMemberAlign();
-  }
-
-  if (mdef->name().contains("dummy")==0)
-    VhdlDocGen::writeLink(mdef,ol);
-  if (equ)
-    ol.insertMemberAlign();
-  ol.docify(" ");
-  VhdlDocGen::formatString(largs,ol,mdef);
-}
-
-QCString VhdlDocGen::splitString(QCString& str,  char c)
-{
-  QCString n=str;
-  int i=str.find(c);
-  if (i>0)
-  {
-    n=str.left(i);
-    str=str.remove(0,i+1);
-  }
-  return n;
-}
-
-bool VhdlDocGen::findConstraintFile(LayoutNavEntry *lne)
-{
-  FileName *fn=Doxygen::inputNameList->first();
-  //LayoutNavEntry *cc = LayoutDocManager::instance().rootNavEntry()->find(LayoutNavEntry::Files);
-
-  LayoutNavEntry *kk = lne->parent();//   find(LayoutNavEntry::Files);
-  // LayoutNavEntry *kks = kk->parent();//   find(LayoutNavEntry::Files);
-  QCString file;
-  QCString co("Constraints");
-  while (fn)
-  {
-    FileDef *fd=fn->first();
-    if (fd->name().contains(".ucf") || fd->name().contains(".qsf"))
-    {
-      file = convertNameToFile(fd->name().data(),FALSE,FALSE);
-      LayoutNavEntry *ucf=new LayoutNavEntry(lne,LayoutNavEntry::MainPage,TRUE,file,co,"");
-      kk->addChild(ucf);
-      break;
-    }
-    fn=Doxygen::inputNameList->next();
-  }
-  return  FALSE;
-}
-
-void VhdlDocGen::writeAlphbeticalClass(OutputList& ol,const ClassDef* cd,const QCString & cname)
-{
-  if (cname.contains("::")==0)
-  {
-    ClassDef*oo=	VhdlDocGen::findArchitecture(cd);
-    ol.writeObjectLink(cd->getReference(),
-        cd->getOutputFileBase(),0,cname);
-    if (oo)
-    {
-      ol.docify(" [");
-      ol.writeObjectLink(oo->getReference(),
-          oo->getOutputFileBase(),0,"arch");
-      ol.docify("] ");
-    }
-  }
-}
-
-
-
-
-//        for cell_inst : [entity] work.proto [ (label|expr) ]
-QCString  VhdlDocGen::parseForConfig(QCString & entity,QCString & arch)
-{
-  int index;
-  QCString label;
-  QCString ent("entity");
-  if (!entity.contains(":")) return "";
-
-  QRegExp exp("[:()\\s]");
-  QStringList ql=QStringList::split(exp,entity,FALSE);
-  //int ii=ql.findIndex(ent);
-  assert(ql.count()>=2);
-  label = ql[0].utf8();
-  entity = ql[1].utf8();
-  if ((index=entity.findRev("."))>=0)
-  {
-    entity.remove(0,index+1);
-  }
-
-  if (ql.count()==3)
-  {
-    arch= ql[2].utf8();
-    ql=QStringList::split(exp,arch,FALSE);
-    if (ql.count()>1) // expression
-      arch="";
-  }
-  return label; // label
-}
-
-
-//        use (configuration|entity|open) work.test [(cellfor)];
-
-QCString  VhdlDocGen::parseForBinding(QCString & entity,QCString & arch)
-{
-  int index;
-  QRegExp exp("[()\\s]");
-
-  QCString label="";
-  QStringList ql=QStringList::split(exp,entity,FALSE);
-
-  if (ql.contains("open"))
-    return "open";
-
-  label=ql[0].utf8();
-
-  entity = ql[1].utf8();
-  if ((index=entity.findRev("."))>=0)
-    entity.remove(0,index+1);
-
-  if (ql.count()==3)
-    arch=ql[2].utf8();
-  return label;
-}
-
-ClassDef*  VhdlDocGen::findArchitecture(QCString identifier, QCString entity_name)
-{
-  QCString archName=entity_name+"::"+identifier;
-  return  Doxygen::classSDict->find(archName.data());
-}
-
-
-//@param arch bit0:flipflop
-//@param binding  e.g entity work.foo(bar)
-//@param label  |label0|label1
-//                          label0:architecture name
-//@param confVhdl of configuration file (identifier::entity_name) or
-//               the architecture if isInlineConf TRUE
-//@param isInlineConf
-//@param confN List of configurations
-
-void assignBinding(ConfNode * conf,QCString label)
-{
-  QList<Entry> instList= getVhdlInstList();
-  QListIterator<Entry> eli(instList);
-  Entry *cur;
-  ClassDef *archClass;
-  QCString archName,entityName;
-  bool allOthers=FALSE;
-
-  if (conf->isInlineConf)
-  {
-    archClass=Doxygen::classSDict->find(conf->confVhdl.data());
-  }
-  else
-  {
-    archName= VhdlDocGen::getIndexWord(label.data(),0);
-    entityName= VhdlDocGen::getIndexWord(conf->confVhdl.data(),1);
-    archClass=VhdlDocGen::findArchitecture(archName,entityName);
-  }
-
-  if (!archClass)
-  {
-    fprintf(stderr,"\n architecture %s not found ! ",conf->confVhdl.data());
-    return;
-  }
-
-  archName=archClass->name();
-
-  QCString allOt=VhdlDocGen::getIndexWord(conf->arch.data(),0);
-
-  if (allOt=="all" || allOt=="others")
-    allOthers=TRUE;
-
-  for (;(cur=eli.current());++eli)
-  {
-    if (conf->isInlineConf &&  (conf->confVhdl!=cur->args))
-      continue;
-
-    if (!conf->isInlineConf &&  (archName!=cur->args))
-      continue;
-
-    if (cur->exception==label || conf->isInlineConf)
-    {
-      QCString sign,archy;
-
-      if (allOthers==FALSE)
-      {
-        archy=conf->arch;
-        sign=cur->name+":"+cur->type;
-      }
-      else
-      {
-        sign=cur->type;
-        archy=VhdlDocGen::getIndexWord(conf->arch.data(),1);
-      }
-
-
-      if (archy==sign && !cur->stat)
-      {
-        // fprintf(stderr," \n label [%s] [%s] [%s]",cur->exception.data(),cur->type.data(),cur->name.data());
-        QCString ent1=conf->binding;
-        QCString arch1;
-        QCString rr=VhdlDocGen::parseForBinding(ent1,arch1);
-        arch1=ent1+"::"+arch1;
-        //ClassDef *archBind=Doxygen::classSDict->find(arch1.data());
-        ClassDef *ent=Doxygen::classSDict->find(ent1.data());
-        QCString	  inst=VhdlDocGen::getIndexWord(cur->args.data(),0);
-        ClassDef *cd=Doxygen::classSDict->find(inst.data());
-
-        if (cd==0 || ent==0)
-          continue;
-
-        addInstance(ent,archClass,cd,cur);
-        cur->stat=TRUE;
-      }
-    }
-  }//for
-}//assignBinding
-
-
-void assignConfiguration(ConfNode* rootNode,QCString label)
-{
-  if (rootNode==NULL) return;
-  uint iter;
-
-  if (!rootNode->isBinding())
-  {
-    //   printf("\n ARCH %s  BIND %s \n",rootNode->arch.data(),rootNode->binding.data());
-    assignBinding(rootNode,label);
-    return;
-  }
-  else
-    label+="|"+rootNode->arch;
-
-
-  for(iter=0;iter<rootNode->confN.count();iter++)
-  {
-    ConfNode* conf= (ConfNode *)rootNode->confN.at(iter);
-    assignConfiguration(conf,label);
-  }
-}
-
-/*
-
-// file foo.vhd
-// enitity foo
-//        .....
-// end entity
-
-// file foo_arch.vhd
-// architecture xxx of foo is
-//          ........
-//  end architecture
-
- */
-void VhdlDocGen::computeVhdlComponentRelations()
-{
-
-  QCString entity,inst,arch,vhd;
-
-  QList<ConfNode> confList =  getVhdlConfiguration();
-  for (uint iter=0;iter<confList.count(); iter++)
-  {
-    ConfNode* conf= (ConfNode *)confList.at(iter);
-    assignConfiguration(conf,"");
-  }
-
-  QList<Entry> qsl= getVhdlInstList();
-  QListIterator<Entry> eli(qsl);
-  Entry *cur;
-
-  for (eli.toFirst();(cur=eli.current());++eli)
-  {
-    if (cur->stat ) //  was bind
-      continue;
-
-    if (cur->includeName=="entity" || cur->includeName=="component" )
-    {
-      entity=cur->includeName+" "+cur->type;
-      QCString rr=VhdlDocGen::parseForBinding(entity,arch);
-    }
-    else if (cur->includeName.isEmpty())
-    {
-      entity=cur->type;
-    }
-    ClassDef *classEntity=Doxygen::classSDict->find(entity);
-    inst=VhdlDocGen::getIndexWord(cur->args.data(),0);
-    ClassDef *cd=Doxygen::classSDict->find(inst);
-    ClassDef *ar=Doxygen::classSDict->find(cur->args);
-
-    if (cd==0 || classEntity==0 )
-      continue;
-
-    addInstance(classEntity,ar,cd,cur);
-
-  }
-}
-
-static void addInstance(ClassDef* classEntity, ClassDef* ar,
-                        ClassDef *cd , Entry *cur,ClassDef* /*archBind*/)
-{
-  if (classEntity==cd) return;
-
-  QCString bName=classEntity->name();
-  //printf("addInstance %s to %s\n", cd->name().data(), classEntity->name().data());
-  QCString n1=cur->type;
-
-  if (!cd->isBaseClass(classEntity, true, 0))
-  {
-    cd->insertBaseClass(classEntity,n1,Public,Normal,0);
-  }
-  else
-  {
-    VhdlDocGen::addBaseClass(cd,classEntity);
-  }
-
-  if (!VhdlDocGen::isSubClass(classEntity,cd,true,0))
-  {
-    classEntity->insertSubClass(cd,Public,Normal,0);
-  }
-
-  if (ar==0) return;
-
-  QCString uu=cur->name;
-  MemberDef *md=new MemberDef(
-      ar->getDefFileName(), cur->startLine,
-      cur->type,uu,uu, 0,
-      Public, Normal, cur->stat,Member,
-      MemberDef::Variable,
-      0,
-      0);
-
-  if (ar->getOutputFileBase()) 
-  {
-    TagInfo tg;
-    tg.anchor = 0;
-    tg.fileName = ar->getOutputFileBase();
-    tg.tagName = 0;
-    md->setTagInfo(&tg);
-  }
-
-  //fprintf(stderr,"\n%s%s%s\n",md->name().data(),cur->brief.data(),cur->doc.data());
-
-  md->setLanguage(SrcLangExt_VHDL);
-  md->setMemberSpecifiers(VhdlDocGen::INSTANTIATION);
-  md->setBriefDescription(cur->brief,cur->briefFile,cur->briefLine);
-  md->setBodySegment(cur->startLine,-1) ;
-  md->setDocumentation(cur->doc.data(),cur->docFile.data(),cur->docLine); 
-  FileDef *fd=ar->getFileDef();
-  md->setBodyDef(fd);
-  ar->insertMember(md);
-  //    printf("\nMemberreference [%p]",md);
-}
-
-
-void  VhdlDocGen::writeRecorUnit(QCString & largs,OutputList& ol ,const MemberDef *mdef)
-{
-  QStringList ql=QStringList::split("#",largs,FALSE);
-  uint len=ql.count();
-  for(uint i=0;i<len;i++)
-  {
-    QCString n=ql[i].utf8();
-    VhdlDocGen::formatString(n,ol,mdef);
-    if ((len-i)>1) ol.lineBreak();
-  }
-}
-
-
-void VhdlDocGen::writeRecUnitDocu(
-    const MemberDef *md,
-    OutputList& ol,
-    QCString largs
-    )
-{
-
-  QStringList ql=QStringList::split("#",largs,FALSE);
-  uint len=ql.count();
-  ol.startParameterList(TRUE);
-  bool first=TRUE;
-  for(uint i=0;i<len;i++)
-  {
-    QCString n=ql[i].utf8();
-    ol.startParameterType(first,"");
-    VhdlDocGen::formatString(n,ol,md);
-    if ((len-i)>1)
-    {
-      ol.endParameterName(FALSE,FALSE,FALSE);
-    }
-    else
-    {
-      ol.endParameterName(TRUE,FALSE,TRUE);
-    }
-
-    first=FALSE;
-  }
-}//#
-
-void VhdlDocGen::writeCodeFragment(OutputList& ol,int start, QCString & codeFragment,const MemberDef* mdef)
-{
-  QStringList qsl=QStringList::split("\n",codeFragment);
-  ol.startCodeFragment();
-  int len = qsl.count();
-  QCString lineNumber;
-  int j;
-  for (j=0;j<len;j++)
-  {
-    lineNumber.sprintf("%05d",start++);
-    lineNumber+=" ";
-    ol.startBold();
-    ol.docify(lineNumber.data());
-    ol.endBold();
-    ol.insertMemberAlign();
-    QCString q=qsl[j].utf8();
-    VhdlDocGen::writeFormatString(q,ol,mdef);
-    ol.docify("\n");
-  }
-  ol.endCodeFragment();
-}
-
-bool VhdlDocGen::isSubClass(ClassDef* cd,ClassDef *scd, bool followInstances,int level)
-{
-  bool found=FALSE;
-  //printf("isBaseClass(cd=%s) looking for %s\n",name().data(),bcd->name().data());
-  if (level>255)
-  {
-    err("Possible recursive class relation while inside %s and looking for %s\n",qPrint(cd->name()),qPrint(scd->name()));
-    abort();
-    return FALSE;
-  }
-
-  if (cd->subClasses())
-  {
-    // Beware: trying to optimise the iterator away using ->first() & ->next()
-    // causes bug 625531
-    BaseClassListIterator bcli(*cd->subClasses());
-    for ( ; bcli.current() && !found ; ++bcli)
-    {
-      ClassDef *ccd=bcli.current()->classDef;
-      if (!followInstances && ccd->templateMaster()) ccd=ccd->templateMaster();
-      //printf("isSubClass() subclass %s\n",ccd->name().data());
-      if (ccd==scd)
-      {
-        found=TRUE;
-      }
-      else 
-      {
-        if (level <256)
-        {
-          found=ccd->isBaseClass(scd,followInstances,level+1);
-        }
-      }
-    }
-  }
-  return found;
-}
-
-void VhdlDocGen::addBaseClass(ClassDef* cd,ClassDef *ent)
-{
-  if (cd->baseClasses())
-  {
-    BaseClassListIterator bcli(*cd->baseClasses());
-    for ( ; bcli.current()  ; ++bcli)
-    {
-      ClassDef *ccd=bcli.current()->classDef;
-      if (ccd==ent) 
-      {
-        QCString n = bcli.current()->usedName;
-        int i = n.find('(');
-        if(i<0)
-        {
-          bcli.current()->usedName.append("(2)");
-          return;
-        }
-        static QRegExp reg("[0-9]+");
-        QCString s=n.left(i);
-        QCString r=n.right(n.length()-i);
-        QCString t=r;
-        VhdlDocGen::deleteAllChars(r,')');
-        VhdlDocGen::deleteAllChars(r,'(');
-        r.setNum(r.toInt()+1);
-        t.replace(reg,r.data());
-        s.append(t.data());
-        bcli.current()->usedName=s;
-        bcli.current()->templSpecifiers=t;
-      }
-    }
-  }
-}
-
+/******************************************************************************
+ *
+ * Copyright (C) 1997-2012 by Dimitri van Heesch.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation under the terms of the GNU General Public License is hereby
+ * granted. No representations are made about the suitability of this software
+ * for any purpose. It is provided "as is" without express or implied warranty.
+ * See the GNU General Public License for more details.
+ *
+ * Documents produced by Doxygen are derivative works derived from the
+ * input used in their production; they are not affected by this license.
+ *
+ */
+/******************************************************************************
+ * Parser for VHDL subset
+ * written by M. Kreis
+ * supports VHDL-87/93/2002
+ * does not support VHDL-AMS
+ ******************************************************************************/
+
+// global includes
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <qcstring.h>
+#include <qfileinfo.h>
+#include <qstringlist.h>
+#include "memberdef.h"
+/* --------------------------------------------------------------- */
+
+// local includes
+#include "vhdldocgen.h"
+#include "message.h"
+#include "config.h"
+#include "doxygen.h"
+#include "util.h"
+#include "language.h"
+#include "commentscan.h"
+#include "index.h"
+#include "definition.h"
+#include "searchindex.h"
+#include "outputlist.h"
+#include "parserintf.h"
+#include "vhdlscanner.h"
+#include "layout.h"
+#include "arguments.h"
+#include "portable.h"
+#include "verilogdocgen.h"
+
+#define theTranslator_vhdlType VhdlDocGen::trVhdlType
+#define COL_SIZE 80 
+
+static QDict<QCString> g_vhdlKeyDict0(17,FALSE);
+static QDict<QCString> g_vhdlKeyDict1(17,FALSE);
+static QDict<QCString> g_vhdlKeyDict2(17,FALSE);
+
+static QDict<QCString> g_xilinxUcfDict(17,FALSE);
+
+static void initUCF(Entry* root,const char* type,QCString &  qcs,int line,QCString & fileName,QCString & brief);
+static void assignConfiguration(ConfNode* ,QCString);
+static void assignBinding(ConfNode* conf,QCString label);
+static void addInstance(ClassDef* entity, ClassDef* arch, ClassDef *inst,Entry *cur,ClassDef* archBind=NULL);
+
+//---------- create svg ------------------------------------------------------------- 
+static void createSVG();
+static void startDot(FTextStream &t);
+static void startTabel(FTextStream &t,QCString className);
+static QList<MemberDef>*  getPorts(ClassDef *cd,int & index);
+static void writeVhdlEntityToolTip(FTextStream& t,ClassDef *cd);
+static void endDot(FTextStream &t);
+static void writeTabel(QList<MemberDef>* port,int index,  FTextStream & t);
+static void endTabel(FTextStream &t);
+static void writeClassToDot(FTextStream &t,ClassDef* cd);
+static void writeVhdlDotLink(FTextStream &t,QCString a,QCString b,char* style);
+//static void writeVhdlPortToolTip(FTextStream& t,QList<MemberDef>* port,ClassDef *cd);
+
+
+
+
+
+//--------------------------------------------------------------------------------------------------
+static void codify(FTextStream &t,const char *str)
+{
+
+  if (str)
+  { 
+    const char *p=str;
+    char c;
+      while (*p)
+    {
+      c=*p++;
+      switch(c)
+      {
+        case '<':  t << "&lt;"; 
+                   break;
+        case '>':  t << "&gt;"; 
+                   break;
+        case '&':  t << "&amp;"; 
+                   break;
+        case '\'': t << "&#39;";
+                   break;
+        case '"':  t << "&quot;"; 
+                   break;
+        default:   t << c;                  
+                   break;
+	  }
+	}
+  }
+}
+
+static void createSVG()
+{
+ 	QCString ov =Config_getString("HTML_OUTPUT");
+    QCString dir="-o "+ov+"/overview.svg";
+	ov+="/vhdl_design.dot ";
+
+	QRegExp ep("[\\s]");
+	QCString vlargs="-Tsvg "+ov+dir ;
+
+	if (portable_system("dot",vlargs)!=0)
+	{
+	 err("could not create dot file");
+	}
+}
+
+// Creates a svg image. All in/out/inout  ports are shown with  brief description and direction.
+// Brief descriptions for entities are shown too.
+void VhdlDocGen::writeOverview()
+{
+ 
+  ClassSDict::Iterator cli(*Doxygen::classSDict);
+  ClassDef *cd;
+  bool found=false;
+  for ( ; (cd=cli.current()) ; ++cli )
+  {
+ 
+   if((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ENTITYCLASS )
+   {
+	found=true;
+	break;
+   };
+  }
+
+ if(!found) return;
+
+  QCString ov =Config_getString("HTML_OUTPUT");
+  QCString fileName=ov+"/vhdl_design.dot";
+  QFile f(fileName);
+  QStringList qli;
+  FTextStream  t(&f);
+
+   if (!f.open(IO_WriteOnly))
+   {
+    fprintf(stderr,"Warning: Cannot open file %s for writing\n",fileName.data());
+	return;
+  }
+
+   startDot(t);
+
+ //ClassSDict::Iterator cli(*Doxygen::classSDict);
+ // ClassDef *cd;
+
+  for (cli.toFirst() ; (cd=cli.current()) ; ++cli )
+  {
+ 
+   if((VhdlDocGen::VhdlClasses)cd->protection()!=VhdlDocGen::ENTITYCLASS )
+    continue;
+ 
+   	int  index;
+   QList<MemberDef>* port= getPorts(cd,index);
+	if(port==0) continue;
+	if(port->count()==0)
+	{
+	    delete port;
+		port=NULL;
+		continue;
+	}
+	
+	startTabel(t,cd->name());
+	writeClassToDot(t,cd);
+	writeTabel(port,index,t);
+	endTabel(t);
+ 
+   // writeVhdlPortToolTip(t,port,cd);
+	writeVhdlEntityToolTip(t,cd);
+    delete port;
+   
+ BaseClassList *bl=cd->baseClasses();
+ if(bl)
+ {
+	BaseClassListIterator bcli(*bl);
+    BaseClassDef *bcd;
+    for ( ; (bcd=bcli.current()) ; ++bcli )
+    {
+      ClassDef *bClass=bcd->classDef; 
+      QCString dotn=cd->name()+":";
+      dotn+=cd->name();
+      QCString csc=bClass->name()+":";
+      csc+=bClass->name();
+	//  fprintf(stderr,"\n <%s| %s>",dotn.data(),csc.data());
+	  writeVhdlDotLink(t,dotn,csc,0);
+	}
+  }// if bl
+ }// for
+
+     endDot(t);
+    //  writePortLinks(t);
+    f.close();
+	createSVG();
+
+}
+
+//------------------------------------------------------------------------------------------------------------------------------------------------------
+
+void  VhdlDocGen::writeOverview(OutputList  & ol)
+{
+ 
+	ol.startFile("vhdl_design_overview.html",0,"overview");
+
+	ol.startTitle();
+	ol.docify("Design Overview");
+	ol.endTitle();
+	ol.writeRuler();
+
+	ol.writeString("<embed  src=\"overview.svg\" ");
+ 
+	// with <img> the links from overview.svg does not work
+	// with<embed  I only get a small window  for large pictures
+
+	//ol.writeString("<img  src=\"overview.svg\" ");// width=\"844\" height=\"503\" ");
+
+	/*
+	QCString num;
+	num=num.setNum(VhdlDocGen::oWidth);
+	ol.writeString(" width=\"");
+	ol.writeString(num.data());
+	ol.writeString("\" height=\"");
+   	num=num.setNum(VhdlDocGen::oHeight);
+    ol.writeString(num.data());
+  
+	ol.writeString("\">");
+	*/
+	ol.writeRuler();
+	//	ol.writeLogo();
+	ol.writeFooter("vhdl_design_overview.html");
+	ol.endFile();
+}
+
+
+static void startDot(FTextStream &t)
+{
+  t <<" digraph G { \n"; 
+  t <<"rankdir=LR \n";
+  t<<"concentrate=true\n";
+  t<<"stylesheet=\"doxygen.css\"\n";
+}
+
+static void endDot(FTextStream &t)
+{
+	t <<" } \n"; 
+}
+
+static void startTabel(FTextStream &t,QCString className)
+{
+	t <<className <<" [ shape=none , fontname=\"arial\",  fontcolor=\"blue\" , \n"; 
+	t<< "label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\">\n";
+}
+
+static void writeVhdlDotLink(FTextStream &t,QCString a,QCString b,char* style)
+{
+ t<<a<<"->"<<b;
+ if(style)
+	 t<<"[style="<<style<<"];\n";
+ t<< "\n";
+}
+
+
+ static QCString formatBriefNote(QCString & brief,ClassDef * cd)
+ {
+ 
+  QRegExp ep("[\n]");
+  QCString vForm;  
+  QCString repl("<BR ALIGN=\"LEFT\"/>");
+  QCString file=cd->getDefFileName();
+  
+  int k=cd->briefLine();
+
+  QStringList qsl=QStringList::split(ep,brief);
+   for(uint j=0;j<qsl.count();j++)
+   {
+	   QCString qcs=qsl[j].data();
+        vForm+=parseCommentAsText(cd,NULL,qcs,file,k);
+		k++;
+        vForm+='\n';
+   }
+  
+   vForm.replace(ep,repl.data());
+   return vForm;
+ }
+
+
+
+static void writeVhdlEntityToolTip(FTextStream& t,ClassDef *cd)
+{
+	
+	QCString brief=cd->briefDescription();
+  	
+	if(brief.isEmpty()) return;  
+		
+    brief=formatBriefNote(brief,cd);
+
+ QCString node="node";
+ node+=VhdlDocGen::getRecordNumber();
+ t << node <<"[shape=none margin=0.1, label=<\n";
+ t<<"<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"2\" >\n ";
+ t<<"<TR><TD BGCOLOR=\"lightcyan\"> ";
+ t<<brief;
+ t<<" </TD></TR></TABLE>>];";
+ QCString dotn=cd->name()+":";
+ dotn+=cd->name();
+ writeVhdlDotLink(t,dotn,node,"dotted");
+}
+
+static void writeColumn(FTextStream &t,MemberDef *md,bool start)
+{
+
+	QCString toolTip;
+	
+	 static QRegExp reg("[%]");
+	bool bidir=(md!=0 &&( stricmp(md->typeString(),"inout")==0));
+
+	 if(md)
+	 {
+	  toolTip=md->briefDescriptionAsTooltip();
+	  if(!toolTip.isEmpty())
+	  {
+	  QCString largs = md->argsString();
+	  if(!largs.isEmpty())
+	  largs=largs.replace(reg," ");
+	  toolTip+=" [";
+	  toolTip+=largs;
+      toolTip+="]";	 
+	  }
+	 
+	 }
+ if(start) 
+   t<<"<TR>\n";
+ 
+ t<<"<TD  ALIGN=\"LEFT\"  ";
+ if(md)
+ {
+  t << "href=\"";
+ t << md->getOutputFileBase()<< Doxygen::htmlFileExtension;
+ t << "#" << md->anchor();
+ t<<"\" ";
+
+  t<<" TOOLTIP=\"";
+   if(!toolTip.isEmpty())
+	   codify(t,toolTip.data());
+   else{
+	  QCString largs = md->argsString();
+	  if(!largs.isEmpty()){ 
+	  largs=largs.replace(reg," ");
+	  codify(t,largs.data());
+	  }
+   }
+	   t<<"\" ";
+
+  t<<" PORT=\"";
+	   t<<md->name();
+  t<<"\" ";
+ }
+ if(!toolTip.isEmpty())
+ {
+	  //if(!toolTip.isEmpty()) 
+
+ if(bidir)
+	  t<<"BGCOLOR=\"orange\">";
+ else
+	 t<<"BGCOLOR=\"azure\">";
+ }
+ else if(bidir)
+ t<<"BGCOLOR=\"pink\">";
+ else
+ t<<"BGCOLOR=\"lightgrey\">";
+ if(md)
+ t<<md->name();
+ else
+t<<" \n";
+ t<<"</TD>\n";
+  
+ if(!start){
+  t<<"</TR>\n";
+
+ }
+}
+
+static void endTabel(FTextStream &t)
+{
+	t <<"</TABLE>>\n";
+    t << "] \n"; 
+}
+
+static void writeClassToDot(FTextStream &t,ClassDef* cd)
+{
+ t<< "<TR><TD COLSPAN=\"2\" BGCOLOR=\"yellow\" ";
+ t<<"PORT=\"";
+ t<<cd->name();
+ t<<"\" ";
+ t << "href=\"";
+t << cd->getOutputFileBase()<< Doxygen::htmlFileExtension;
+ t<<"\" ";
+ t<<">";
+ t<<cd->name();
+t<<" </TD></TR>\n"; 
+}
+
+
+
+static QList<MemberDef>*  getPorts(ClassDef *cd,int & index)
+{
+  MemberDef* md;
+  QList<MemberDef> *portList=new QList<MemberDef>;
+  MemberList *ml=cd->getMemberList(MemberList::variableMembers);
+ 
+  if(ml==0) return NULL;
+
+   MemberListIterator fmni(*ml);
+
+  for (fmni.toFirst();(md=fmni.current());++fmni)
+  {
+	  if (md->getMemberSpecifiers()==VhdlDocGen::PORT)
+	  {
+			  portList->append(md);
+		  }
+	  
+  } 
+ 
+  return portList;
+}
+
+//writeColumn(FTextStream &t,QCString name,bool start)
+
+static void writeTabel(QList<MemberDef>* port,int index,  FTextStream & t)
+{
+    QCString space(" ");
+	MemberDef *md;
+	uint len=port->count();
+	
+	QList<MemberDef> inPorts;
+	QList<MemberDef> outPorts;
+	
+	
+	for(uint j=0;j<len;j++)
+	{
+		md=(MemberDef*)port->at(j);
+	    QCString qc=md->typeString();
+		if(qc=="in")
+          inPorts.append(md);
+        else
+          outPorts.append(md);			
+	}	
+		
+	 int inp=inPorts.count();
+	 int outp=outPorts.count();
+	 
+     int maxLen;
+	
+	 if(inp>=outp) 
+		maxLen=inp;
+	else
+	   maxLen=outp;
+	
+	for(int i=0;i<maxLen;i++)
+	{
+        //write inports
+		if(i<inp)
+		{
+		md=(MemberDef*)inPorts.at(i);
+		 writeColumn(t,md,true);
+		}
+		else
+		 writeColumn(t,NULL,true);
+		
+		if(i<outp)
+		{
+		  	md=(MemberDef*)outPorts.at(i);
+			writeColumn(t,md,false);
+		}
+		else
+		 writeColumn(t,NULL,false);
+		
+    }	
+}
+
+
+
+
+//--------------------------------------------------------------------------------------------------
+
+
+VhdlDocGen::VhdlDocGen()
+{
+}
+
+VhdlDocGen::~VhdlDocGen()
+{
+}
+
+void VhdlDocGen::init()
+{
+
+ // vhdl keywords inlcuded VHDL 2008
+const char* g_vhdlKeyWordMap0[] =
+{
+  "abs","access","after","alias","all","and","architecture","array","assert","assume","assume_guarantee","attribute",
+  "begin","block","body","buffer","bus",
+  "case","component","configuration","constant","context","cover",
+  "default","disconnect","downto",
+  "else","elsif","end","entity","exit",
+  "fairness","file","for","force","function",
+  "generate","generic","group","guarded",
+  "if","impure","in","inertial","inout","is",
+  "label","library","linkage","literal","loop",
+  "map","mod",
+  "nand","new","next","nor","not","null",
+  "of","on","open","or","others","out",
+  "package","parameter","port","postponed","procedure","process","property","proctected","pure",
+  "range","record","register","reject","release","restrict","restrict_guarantee","rem","report","rol","ror","return",
+  "select","sequence","severity","signal","shared","sla","sll","sra","srl","strong","subtype",
+  "then","to","transport","type",
+  "unaffected","units","until","use",
+  "variable","vmode","vprop","vunit",
+  "wait","when","while","with",
+  "xor","xnor",
+  0
+};
+
+// type
+const char* g_vhdlKeyWordMap1[] =
+{
+  "natural","unsigned","signed","string","boolean", "bit","bit_vector","character",
+  "std_ulogic","std_ulogic_vector","std_logic","std_logic_vector","integer",
+  "real","float","ufixed","sfixed","time",0
+};
+
+// logic
+const char* g_vhdlKeyWordMap2[] =
+{
+  "abs","and","or","not","mod", "xor","rem","xnor","ror","rol","sla",
+  "sll",0
+};
+
+  int j=0;
+  g_vhdlKeyDict0.setAutoDelete(TRUE);
+  g_vhdlKeyDict1.setAutoDelete(TRUE);
+  g_vhdlKeyDict2.setAutoDelete(TRUE);
+
+  j=0;
+  while (g_vhdlKeyWordMap0[j])
+  {
+    g_vhdlKeyDict0.insert(g_vhdlKeyWordMap0[j],
+	               new QCString(g_vhdlKeyWordMap0[j]));
+    j++;
+  }
+
+  j=0;
+  while (g_vhdlKeyWordMap1[j])
+  {
+    g_vhdlKeyDict1.insert(g_vhdlKeyWordMap1[j],
+	               new QCString(g_vhdlKeyWordMap1[j]));
+    j++;
+  }
+
+  j=0;
+  while (g_vhdlKeyWordMap2[j])
+  {
+    g_vhdlKeyDict2.insert(g_vhdlKeyWordMap2[j],
+	               new QCString(g_vhdlKeyWordMap2[j]));
+    j++;
+  }
+
+}// buildKeyMap
+
+/*!
+ * returns the color of a keyword
+ */
+
+QCString* VhdlDocGen::findKeyWord(const QCString& word)
+{
+  static  QCString g_vhdlkeyword("vhdlkeyword");
+  static  QCString g_vhdltype("comment");
+  static  QCString g_vhdllogic("vhdllogic");
+
+  if (word.isEmpty() || word.at(0)=='\0') return 0;
+  //printf("VhdlDocGen::findKeyWord(%s)\n",word.data());
+
+  if (g_vhdlKeyDict0.find(word.lower()))
+    return &g_vhdlkeyword;
+
+  if (g_vhdlKeyDict1.find(word.lower()))
+    return &g_vhdltype;
+
+  if (g_vhdlKeyDict2.find(word.lower()))
+    return &g_vhdllogic;
+
+  return 0;
+}
+
+/*!
+ * returns the parsed entry at line xxx
+ */
+
+
+
+bool found =FALSE;
+static Entry eMerge;
+
+ClassDef *VhdlDocGen::getClass(const char *name)
+{
+  if (name==0 || name[0]=='\0') return 0;
+
+  ClassDef *cd=0;
+  QCString temp(name);
+  //temp=temp.lower();
+  temp=temp.stripWhiteSpace();
+  cd= Doxygen::classSDict->find(temp.data());
+  return cd;
+}
+
+
+
+
+ClassDef* VhdlDocGen::getPackageName(const QCString & name)
+{
+  ClassDef* cd=0;
+  QStringList ql=QStringList::split(".",name,FALSE);
+  cd=getClass(name);
+
+  return cd;
+}
+
+MemberDef* VhdlDocGen::findMember(const QCString& className, const QCString& memName)
+{
+  QDict<QCString> packages(17,FALSE);
+  packages.setAutoDelete(TRUE);
+  ClassDef* cd;
+  MemberDef *mdef=0;
+
+  cd=getClass(className);
+  //printf("VhdlDocGen::findMember(%s,%s)=%p\n",className.data(),memName.data(),cd);
+  if (cd==0) return 0;
+
+  mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::variableMembers);
+  if (mdef) return mdef;
+  mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
+  if (mdef) return mdef;
+
+  // nothing found so far
+  // if we are an architecture or package body search in entitiy
+
+  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS ||
+      (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
+  {
+    Definition *d = cd->getOuterScope();
+    // searching upper/lower case names
+
+    QCString tt=d->name();
+    ClassDef *ecd =getClass(tt);
+    if (!ecd)
+    {
+      tt=tt.upper();
+      ecd =getClass(tt);
+    }
+    if (!ecd)
+    {
+      tt=tt.lower();
+      ecd =getClass(tt);
+    }
+
+    if (ecd) //d && d->definitionType()==Definition::TypeClass)
+    {
+      //ClassDef *ecd = (ClassDef*)d;
+      mdef=VhdlDocGen::findMemberDef(ecd,memName,MemberList::variableMembers);
+      if (mdef) return mdef;
+      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
+      if (mdef) return mdef;
+    }
+    //cd=getClass(getClassName(cd));
+    //if (!cd) return 0;
+  }
+  // nothing found , so we are now searching all included packages
+  VhdlDocGen::findAllPackages(className,packages);
+  //cd=getClass(className.data());
+  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS ||
+      (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
+  {
+    Definition *d = cd->getOuterScope();
+
+    QCString tt=d->name();
+    ClassDef *ecd =getClass(tt);
+    if (!ecd)
+    {
+      tt=tt.upper();
+      ecd =getClass(tt);
+    }
+    if (!ecd)
+    {
+      tt=tt.lower();
+      ecd =getClass(tt);
+    }
+
+    if (ecd) //d && d->definitionType()==Definition::TypeClass)
+    {
+      VhdlDocGen::findAllPackages(ecd->className(),packages);
+    }
+  }
+
+  QDictIterator<QCString> packli(packages);
+  QCString *curString;
+  for (packli.toFirst();(curString=packli.current());++packli)
+  {
+    if (curString)
+    {
+      cd=VhdlDocGen::getPackageName(*curString);
+      if (!cd)
+      {
+        *curString=curString->upper();
+        cd=VhdlDocGen::getPackageName(*curString);
+      }
+      if (!cd)
+      {
+        *curString=curString->lower();
+        cd=VhdlDocGen::getPackageName(*curString);
+      }
+    }
+    if (cd)
+    {
+      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::variableMembers);
+      if (mdef)  return mdef;
+      mdef=VhdlDocGen::findMemberDef(cd,memName,MemberList::pubMethods);
+      if (mdef) return mdef;
+    }
+  } // for
+  return 0;
+}//findMember
+
+/**
+ *  This function returns the entity|package
+ *  in which the key (type) is found
+ */
+
+MemberDef* VhdlDocGen::findMemberDef(ClassDef* cd,const QCString& key,MemberList::ListType type)
+{
+  //    return cd->getMemberByName(key);//does not work
+  MemberDef *md=0;
+
+  MemberList *ml=    cd->getMemberList(type);
+  if (ml==0) return 0;
+
+  MemberListIterator fmni(*ml);
+
+  for (fmni.toFirst();(md=fmni.current());++fmni)
+  {
+    if (stricmp(key.data(),md->name().data())==0)
+    {
+      return md;
+    }
+  }
+  return 0;
+}//findMemberDef
+
+/*!
+ * finds all included packages of an Entity or Package
+ */
+
+void VhdlDocGen::findAllPackages(const QCString& className,QDict<QCString>& qdict)
+{
+  ClassDef *cdef=getClass(className);
+  if (cdef)
+  {
+    MemberList *mem=cdef->getMemberList(MemberList::variableMembers);
+    MemberDef *md;
+
+    if (mem)
+    {
+      MemberListIterator fmni(*mem);
+      for (fmni.toFirst();(md=fmni.current());++fmni)
+      {
+        if (VhdlDocGen::isPackage(md))
+        {
+          QCString *temp1=new QCString(md->name().data());
+          //*temp1=temp1->lower();
+          QCString p(md->name().data());
+          //p=p.lower();
+          ClassDef* cd=VhdlDocGen::getPackageName(*temp1);
+          if (cd)
+          {
+            QCString *ss=qdict.find(*temp1);
+            if (ss==0)
+            {
+              qdict.insert(p,temp1);
+              QCString tmp=cd->className();
+              VhdlDocGen::findAllPackages(tmp,qdict);
+            }
+            else delete temp1;
+          }
+          else delete temp1;
+        }
+      }//for
+    }//if
+  }//cdef
+}// findAllPackages
+
+/*!
+ * returns the function with the matching argument list
+ * is called in vhdlcode.l
+ */
+
+MemberDef* VhdlDocGen::findFunction(const QList<Argument> &ql,
+    const QCString& funcname,
+    const QCString& package, bool /*type*/)
+{
+  MemberDef* mdef=0;
+  //int funcType;
+  ClassDef *cdef=getClass(package.data());
+  if (cdef==0) return 0;
+
+  //if (type)
+  //  funcType=VhdlDocGen::PROCEDURE;
+  //else
+  //  funcType=VhdlDocGen::FUNCTION;
+
+  MemberList *mem=cdef->getMemberList(MemberList::pubMethods);
+
+  if (mem)
+  {
+    MemberListIterator fmni(*mem);
+    for (fmni.toFirst();(mdef=fmni.current());++fmni)
+    {
+      QCString mname=mdef->name();
+      if ((VhdlDocGen::isProcedure(mdef) || VhdlDocGen::isVhdlFunction(mdef)) && (VhdlDocGen::compareString(funcname,mname)==0))
+      {
+        LockingPtr<ArgumentList> alp = mdef->argumentList();
+
+        //  ArgumentList* arg2=mdef->getArgumentList();
+        if (alp==0) break;
+        ArgumentListIterator ali(*alp.pointer());
+        ArgumentListIterator ali1(ql);
+
+        if (ali.count() != ali1.count()) break;
+
+        Argument *arg,*arg1;
+        int equ=0;
+
+        for (;(arg=ali.current());++ali)
+        {
+          arg1=ali1.current(); ++ali1;
+          equ+=abs(VhdlDocGen::compareString(arg->type,arg1->type));
+
+          QCString s1=arg->type;
+          QCString s2=arg1->type;
+          VhdlDocGen::deleteAllChars(s1,' ');
+          VhdlDocGen::deleteAllChars(s2,' ');
+          equ+=abs(VhdlDocGen::compareString(s1,s2));
+          s1=arg->attrib;
+          s2=arg1->attrib;
+          VhdlDocGen::deleteAllChars(s1,' ');
+          VhdlDocGen::deleteAllChars(s2,' ');
+          equ+=abs(VhdlDocGen::compareString(s1,s2));
+          // printf("\n 1. type [%s] name [%s] attrib [%s]",arg->type,arg->name,arg->attrib);
+          // printf("\n 2. type [%s] name [%s] attrib [%s]",arg1->type,arg1->name,arg1->attrib);
+        } // for
+        if (equ==0) return mdef;
+      }//if
+    }//for
+  }//if
+  return mdef;
+} //findFunction
+
+
+
+
+/*!
+ * returns the class title+ref
+ */
+
+QCString VhdlDocGen::getClassTitle(const ClassDef *cd)
+{
+ 
+     static bool optVerilog = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+  if(optVerilog)
+   return VerilogDocGen::getClassTitle(cd);
+
+	
+  QCString pageTitle;
+  if (cd==0) return "";
+  pageTitle+=cd->displayName();
+  pageTitle=VhdlDocGen::getClassName(cd);
+  int ii=cd->protection();
+  pageTitle+=" ";
+  pageTitle+=theTranslator_vhdlType(ii+2,TRUE);
+  pageTitle+=" ";
+  return pageTitle;
+} // getClassTitle
+
+/* returns the class name without their prefixes */
+
+QCString VhdlDocGen::getClassName(const ClassDef* cd)
+{
+  QCString temp;
+  if (cd==0) return "";
+
+  if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
+  {
+    temp=cd->name();
+    temp.stripPrefix("_");
+    return temp;
+  }
+  //if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::ARCHITECTURECLASS)
+  //{
+  //  QStringList qlist=QStringList::split("-",cd->className(),FALSE);
+  //  if (qlist.count()>1)
+  //    return (QCString)qlist[1];
+  //  return "";
+  //}
+  return substitute(cd->className(),"::",".");
+}
+
+/*!
+ * writes an inline link form entity|package to architecture|package body and vice verca
+ */
+
+void VhdlDocGen::writeInlineClassLink(const ClassDef* cd ,OutputList& ol)
+{
+  QList<QCString> ql;
+  ql.setAutoDelete(TRUE);
+  QCString nn=cd->className();
+  int ii=(int)cd->protection()+2;
+
+  QCString type;
+  if (ii==VhdlDocGen::ENTITY)
+    type+=theTranslator_vhdlType(VhdlDocGen::ARCHITECTURE,TRUE);
+  else if (ii==VhdlDocGen::ARCHITECTURE)
+    type+=theTranslator_vhdlType(VhdlDocGen::ENTITY,TRUE);
+  else if (ii==VhdlDocGen::PACKAGE_BODY)
+    type+=theTranslator_vhdlType(VhdlDocGen::PACKAGE,TRUE);
+  else if (ii==VhdlDocGen::PACKAGE)
+    type+=theTranslator_vhdlType(VhdlDocGen::PACKAGE_BODY,TRUE);
+  else
+    type+="";
+
+  //type=type.lower();
+  type+=" >> ";
+  ol.disable(OutputGenerator::RTF);
+  ol.disable(OutputGenerator::Man);
+
+  if (ii==VhdlDocGen::PACKAGE_BODY)
+  {
+    nn.stripPrefix("_");
+    cd=getClass(nn.data());
+  }
+  else  if (ii==VhdlDocGen::PACKAGE)
+  {
+    nn.prepend("_");
+    cd=getClass(nn.data());
+  }
+  else if (ii==VhdlDocGen::ARCHITECTURE)
+  {
+    QStringList qlist=QStringList::split("-",nn,FALSE);
+    nn=qlist[1].utf8();
+    cd=VhdlDocGen::getClass(nn.data());
+  }
+
+  QCString opp;
+  if (ii==VhdlDocGen::ENTITY)
+  {
+    VhdlDocGen::findAllArchitectures(ql,cd);
+    int j=ql.count();
+    for (int i=0;i<j;i++)
+    {
+      QCString *temp=ql.at(i);
+      QStringList qlist=QStringList::split("-",*temp,FALSE);
+      QCString s1=qlist[0].utf8();
+      QCString s2=qlist[1].utf8();
+      s1.stripPrefix("_");
+      if (j==1) s1.resize(0);
+      ClassDef*cc = getClass(temp->data());
+      if (cc)
+      {
+        VhdlDocGen::writeVhdlLink(cc,ol,type,s2,s1);
+      }
+    }
+  }
+  else
+  {
+    VhdlDocGen::writeVhdlLink(cd,ol,type,nn,opp);
+  }
+
+  ol.enable(OutputGenerator::Man);
+  ol.enable(OutputGenerator::RTF);
+
+}// write
+
+/*
+ * finds all architectures which belongs to an entiy
+ */
+void VhdlDocGen::findAllArchitectures(QList<QCString>& qll,const ClassDef *cd)
+{
+  ClassDef *citer;
+  ClassSDict::Iterator cli(*Doxygen::classSDict);
+  for ( ; (citer=cli.current()) ; ++cli )
+  {
+    QCString jj=citer->className();
+    if (cd != citer && jj.contains('-')!=-1)
+    {
+      QStringList ql=QStringList::split("-",jj,FALSE);
+      QCString temp=ql[1].utf8();
+      if (stricmp(cd->className().data(),temp.data())==0)
+      {
+        QCString *cl=new QCString(jj.data());
+        qll.insert(0,cl);
+      }
+    }
+  }// for
+}//findAllArchitectures
+
+ClassDef* VhdlDocGen::findArchitecture(const ClassDef *cd)
+{
+  ClassDef *citer;
+  QCString nn=cd->name();
+  ClassSDict::Iterator cli(*Doxygen::classSDict);
+
+  for ( ; (citer=cli.current()) ; ++cli )
+  {
+    QCString jj=citer->name();
+    QStringList ql=QStringList::split(":",jj,FALSE);
+    if (ql.count()>1)
+    {
+      if (ql[0].utf8()==nn )
+      {
+        return citer;
+      }
+    }
+  }
+  return 0;
+}
+/*
+ * writes the link entity >> .... or architecture >> ...
+ */
+
+void VhdlDocGen::writeVhdlLink(const ClassDef* ccd ,OutputList& ol,QCString& type,QCString& nn,QCString& behav)
+{
+  if (ccd==0)  return;
+  QCString temp=ccd->getOutputFileBase();
+  ol.startBold();
+  ol.docify(type.data());
+  ol.endBold();
+  nn.stripPrefix("_");
+  ol.writeObjectLink(ccd->getReference(),ccd->getOutputFileBase(),0,nn.data());
+
+  if (!behav.isEmpty())
+  {
+    behav.prepend("  ");
+    ol.startBold();
+    ol.docify(behav.data());
+    ol.endBold();
+  }
+
+  ol.lineBreak();
+}
+
+bool VhdlDocGen::compareString(const QCString& s1,const QCString& s2)
+{
+  QCString str1=s1.stripWhiteSpace();
+  QCString str2=s2.stripWhiteSpace();
+
+  return stricmp(str1.data(),str2.data());
+}
+
+
+/*!
+ * strips the "--" prefixes of vhdl comments
+ */
+void VhdlDocGen::prepareComment(QCString& qcs)
+{
+  
+ QCString temp;
+     static bool optVerilog       = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+	
+const char* s="--!";
+  //const char *start="--!{";
+  //const char *end="--!}";
+  
+   if(optVerilog)
+     s=vlogComment;
+     else
+    s="--!";
+
+  int index=0;
+
+  while (TRUE)
+  {
+    index=qcs.find(s,0,TRUE);
+    if (index<0) break;
+    qcs=qcs.remove(index,strlen(s));
+  }
+  qcs=qcs.stripWhiteSpace();
+}
+
+
+/*!
+ * parses a function proto
+ * @param text function string
+ * @param qlist stores the function types
+ * @param name points to the function name
+ * @param ret Stores the return type
+ * @param doc ???
+ */
+void VhdlDocGen::parseFuncProto(const char* text,QList<Argument>& qlist,
+    QCString& name,QCString& ret,bool doc)
+{
+  (void)qlist; //unused
+  int index,end;
+  QCString s1(text);
+  QCString temp;
+
+  index=s1.find("(");
+  end=s1.findRev(")");
+
+  if ((end-index)>0)
+  {
+    QCString tt=s1.mid(index,(end-index+1));
+    temp=s1.mid(index+1,(end-index-1));
+    //getFuncParams(qlist,temp);
+  }
+  if (doc)
+  {
+    name=s1.left(index);
+    name=name.stripWhiteSpace();
+    if ((end-index)>0)
+    {
+      ret="function";
+    }
+    return;
+  }
+  else
+  {
+    QCString s1(text);
+    s1=s1.stripWhiteSpace();
+    int i=s1.find("(",0,FALSE);
+    int s=s1.find(QRegExp("[ \\t]"));
+    if (i==-1 || i<s)
+      s1=VhdlDocGen::getIndexWord(s1.data(),1);
+    else // s<i, s=start of name, i=end of name
+      s1=s1.mid(s,(i-s));
+
+    name=s1.stripWhiteSpace();
+  }
+  index=s1.findRev("return",-1,FALSE);
+  if (index !=-1)
+  {
+    ret=s1.mid(index+6,s1.length());
+    ret=ret.stripWhiteSpace();
+    VhdlDocGen::deleteCharRev(ret,';');
+  }
+}
+
+/*
+ *  returns the n'th word of a string
+ */
+
+QCString VhdlDocGen::getIndexWord(const char* c,int index)
+{
+  QStringList ql;
+  QCString temp(c);
+  QRegExp reg("[\\s:|]");
+
+  ql=QStringList::split(reg,temp,FALSE);
+
+  if (ql.count() > (unsigned int)index)
+  {
+    return ql[index].utf8();
+  }
+
+  return "";
+}
+
+
+QCString VhdlDocGen::getProtectionName(int prot)
+{
+  
+ static bool optVerilog    = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+ if(optVerilog)
+	 {
+       if(prot==Public) return "Module";
+		   return "Primitive";
+	 }
+
+	
+	
+	
+if (prot==VhdlDocGen::ENTITYCLASS)
+    return "entity";
+  else if (prot==VhdlDocGen::ARCHITECTURECLASS)
+    return "architecture";
+  else if (prot==VhdlDocGen::PACKAGECLASS)
+    return "package";
+  else if (prot==VhdlDocGen::PACKBODYCLASS)
+    return "package body";
+
+  return "";
+}
+
+QCString VhdlDocGen::trTypeString(int type)
+{
+  
+     static bool optVerilog       = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+    if(optVerilog)
+    return VerilogDocGen::convertTypeToString(type);
+ 
+	
+	
+	
+ switch(type)
+  {
+    case VhdlDocGen::LIBRARY:        return "Library";
+    case VhdlDocGen::ENTITY:         return "Entity";
+    case VhdlDocGen::PACKAGE_BODY:   return "Package Body";
+    case VhdlDocGen::ATTRIBUTE:      return "Attribute";
+    case VhdlDocGen::PACKAGE:        return "Package";
+    case VhdlDocGen::SIGNAL:         return "Signal";
+    case VhdlDocGen::COMPONENT:      return "Component";
+    case VhdlDocGen::CONSTANT:       return "Constant";
+    case VhdlDocGen::TYPE:           return "Type";
+    case VhdlDocGen::SUBTYPE:        return "Subtype";
+    case VhdlDocGen::FUNCTION:       return "Function";
+    case VhdlDocGen::RECORD:         return "Record";
+    case VhdlDocGen::PROCEDURE:      return "Procedure";
+    case VhdlDocGen::ARCHITECTURE:   return "Architecture";
+    case VhdlDocGen::USE:            return "Package";
+    case VhdlDocGen::PROCESS:        return "Process";
+    case VhdlDocGen::PORT:           return "Port";
+    case VhdlDocGen::GENERIC:        return "Generic";
+    case VhdlDocGen::UNITS:          return "Units";
+                                     //case VhdlDocGen::PORTMAP:        return "Port Map";
+    case VhdlDocGen::SHAREDVARIABLE: return "Shared Variable";
+    case VhdlDocGen::GROUP:          return "Group";
+    case VhdlDocGen::VFILE:          return "File";
+    case VhdlDocGen::INSTANTIATION: return "Instantiation";
+    case VhdlDocGen::ALIAS:          return "Alias";
+    case VhdlDocGen::CONFIG:         return "Configuration";
+    case VhdlDocGen::MISCELLANEOUS:  return "Miscellaneous";
+    case VhdlDocGen::UCF_CONST:      return "Constraints";
+    default:                         return "";
+  }
+} // convertType
+
+/*!
+ * deletes a char backwards in a string
+ */
+
+bool VhdlDocGen::deleteCharRev(QCString &s,char c)
+{
+  int index=s.findRev(c,-1,FALSE);
+  if (index > -1)
+  {
+    QCString qcs=s.remove(index,1);
+    s=qcs;
+    return TRUE;
+  }
+  return FALSE;
+}
+
+void VhdlDocGen::deleteAllChars(QCString &s,char c)
+{
+  int index=s.findRev(c,-1,FALSE);
+  while (index > -1)
+  {
+    QCString qcs=s.remove(index,1);
+    s=qcs;
+    index=s.findRev(c,-1,FALSE);
+  }
+}
+
+
+static int recordCounter=0;
+
+/*!
+ * returns the next number of a record|unit member
+ */
+
+QCString VhdlDocGen::getRecordNumber()
+{
+  char buf[12];
+  sprintf(buf,"%d",recordCounter++);
+  QCString qcs(&buf[0]);
+  return qcs;
+}
+
+/*!
+ * returns the next number of an anonymous process
+ */
+
+QCString VhdlDocGen::getProcessNumber()
+{
+  static int stringCounter;
+    static bool optVerilog=Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+  
+    QCString qcs;
+    char buf[8];
+  
+    if(optVerilog)
+     qcs="ALWAYS_";
+    else
+     qcs="PROCESS_";
+
+  sprintf(buf,"%d",stringCounter++);
+  qcs.append(&buf[0]);
+  return qcs;
+}
+
+/*!
+ * writes a colored and formatted string
+ */
+
+void VhdlDocGen::writeFormatString(const QCString& s,OutputList&ol,const MemberDef* mdef)
+{
+    static bool optVerilog=Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+  QRegExp reg("[\\[\\]\\.\\/\\:\\<\\>\\:\\s\\,\\;\\'\\+\\-\\*\\|\\&\\=\\(\\)\"]");
+  QCString qcs = s;
+  qcs+=QCString(" ");// parsing the last sign
+ const  QCString *ss;
+  QCString find=qcs;
+  QCString temp=qcs;
+  char buf[2];
+  buf[1]='\0';
+
+  int j;
+  int len;
+  j = reg.match(temp.data(),0,&len);
+
+  ol.startBold();
+  if (j>=0)
+  {
+    while (j>=0)
+    {
+      find=find.left(j);
+      buf[0]=temp[j];
+        if(optVerilog)
+        ss=VerilogDocGen::findKeyWord(find);
+      else
+        ss=VhdlDocGen::findKeyWord(find);
+      bool k=VhdlDocGen::isNumber(find); // is this a number
+      if (k)
+      {
+        ol.docify(" ");
+        VhdlDocGen::startFonts(find,"vhdldigit",ol);
+        ol.docify(" ");
+      }
+      else if (j != 0 && ss)
+      {
+        VhdlDocGen::startFonts(find,ss->data(),ol);
+      }
+      else
+      {
+        if (j>0)
+        {
+          VhdlDocGen::writeStringLink(mdef,find,ol);
+        }
+      }
+      VhdlDocGen::startFonts(&buf[0],"vhdlchar",ol);
+
+      QCString st=temp.remove(0,j+1);
+      find=st;
+      if (!find.isEmpty() && find.at(0)=='"')
+      {
+        int ii=find.find('"',2);
+        if (ii>1)
+        {
+          QCString com=find.left(ii+1);
+          VhdlDocGen::startFonts(com,"keyword",ol);
+          temp=find.remove(0,ii+1);
+        }
+      }
+      else
+      {
+        temp=st;
+      }
+      j = reg.match(temp.data(),0,&len);
+    }//while
+  }//if
+  else
+  {
+    VhdlDocGen::startFonts(find,"vhdlchar",ol);
+  }
+  ol.endBold();
+}// writeFormatString
+
+/*!
+ * returns TRUE if this string is a number
+ */
+
+bool VhdlDocGen::isNumber(const QCString& s)
+{
+  static QRegExp regg("[0-9][0-9eEfFbBcCdDaA_.#-+?xXzZ]*");
+  static QRegExp reggVerilog("[0-9]+[']*[0-9a-fA-FhHoOxXzZ._?]*");
+  static QRegExp reggVerilog1("['][0-9a-fA-FhHoOxXzZ._?]+");
+  static bool optVerilog=Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+  if (s.isEmpty()) return FALSE;
+  int j,len;
+  
+  
+    if(optVerilog){
+    QCString t=s;
+    VhdlDocGen::deleteAllChars(t,' ');
+     j = reggVerilog.match(t.data(),0,&len);
+     if ((j==0) && (len==(int)t.length())) return true; 
+     j = reggVerilog1.match(t.data(),0,&len);
+     if ((j==0) && (len==(int)t.length())) return true;
+     return false;
+    }  
+  else 
+  j = regg.match(s.data(),0,&len);
+ 
+  if ((j==0) && (len==(int)s.length())) return TRUE;
+  return FALSE;
+
+}// isNumber
+
+void VhdlDocGen::startFonts(const QCString& q, const char *keyword,OutputList& ol)
+{
+  ol.startFontClass(keyword);
+  ol.docify(q.data());
+  ol.endFontClass();
+}
+
+/*!
+ * inserts white spaces for  better readings
+ * and writes a colored string to the output
+ */
+
+void VhdlDocGen::formatString(const QCString &s, OutputList& ol,const MemberDef* mdef)
+{
+ 
+	    static bool optVerilog  = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+  if(optVerilog){
+      VhdlDocGen::writeFormatString(s,ol,mdef);
+       return;
+  }
+
+	
+	
+  QCString qcs = s;
+  QCString temp(qcs.length());
+  qcs.stripPrefix(":");
+  qcs.stripPrefix("is");
+  qcs.stripPrefix("IS");
+  qcs.stripPrefix("of");
+  qcs.stripPrefix("OF");
+
+  // VhdlDocGen::deleteCharRev(qcs,';');
+  //char white='\t';
+  int len = qcs.length();
+  unsigned int index=1;//temp.length();
+
+  for (int j=0;j<len;j++)
+  {
+    char c=qcs[j];
+    char b=c;
+    if (j>0) b=qcs[j-1];
+    if (c=='"' || c==',' || c=='\''|| c=='(' || c==')'  || c==':' || c=='[' || c==']' ) // || (c==':' && b!='=')) // || (c=='=' && b!='>'))
+    {
+      if (temp.at(index-1) != ' ')
+      {
+        temp+=" ";
+      }
+      temp+=c;
+      temp+=" ";
+    }
+    else if (c=='=')
+    {
+      if (b==':') // := operator
+      {
+        temp.replace(index-1,1,"=");
+        temp+=" ";
+      }
+      else // = operator
+      {
+        temp+=" ";
+        temp+=c;
+        temp+=" ";
+      }
+    }
+    else
+    {
+      temp+=c;
+    }
+
+    index=temp.length();
+  }// for
+  temp=temp.stripWhiteSpace();
+  // printf("\n [%s]",qcs.data());
+  VhdlDocGen::writeFormatString(temp,ol,mdef);
+}
+
+/*!
+ * writes a procedure prototype to the output
+ */
+
+void VhdlDocGen::writeProcedureProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
+{
+  ArgumentListIterator ali(*al);
+  Argument *arg;
+  bool sem=FALSE;
+  int len=al->count();
+  ol.docify("( ");
+  if (len > 2)
+  {
+    ol.lineBreak();
+  }
+  for (;(arg=ali.current());++ali)
+  {
+    ol.startBold();
+    if (sem && len <3)
+      ol.writeChar(',');
+
+    QCString nn=arg->name;
+    nn+=": ";
+
+    QCString *str=VhdlDocGen::findKeyWord(arg->defval);
+    arg->defval+=" ";
+    if (str)
+    {
+      VhdlDocGen::startFonts(arg->defval,str->data(),ol);
+    }
+    else
+    {
+      VhdlDocGen::startFonts(arg->defval,"vhdlchar",ol); // write type (variable,constant etc.)
+    }
+
+    VhdlDocGen::startFonts(nn,"vhdlchar",ol); // write name
+    if (stricmp(arg->attrib.data(),arg->type.data()) != 0)
+      VhdlDocGen::startFonts(arg->attrib.lower(),"stringliteral",ol); // write in|out
+    ol.docify(" ");
+    VhdlDocGen::formatString(arg->type,ol,mdef);
+    sem=TRUE;
+    ol.endBold();
+    if (len > 2)
+    {
+      ol.lineBreak();
+      ol.docify("  ");
+    }
+  }//for
+
+  ol.docify(" )");
+
+
+}
+
+/*!
+ * writes a function prototype to the output
+ */
+
+void VhdlDocGen::writeFunctionProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
+{
+  
+   
+	
+  if (al==0) return;
+  ArgumentListIterator ali(*al);
+  Argument *arg;
+  bool sem=FALSE;
+  int len=al->count();
+  ol.startBold();
+  ol.docify(" ( ");
+  ol.endBold();
+  if (len>2)
+  {
+    ol.lineBreak();
+  }
+  for (;(arg=ali.current());++ali)
+  {
+    ol.startBold();
+    QCString att=arg->defval;
+    bool bGen=att.stripPrefix("gen!");
+
+    if (sem && len < 3)
+    {
+      ol.docify(" , ");
+    }
+
+    if (bGen) {
+      VhdlDocGen::formatString(QCString("generic "),ol,mdef);
+    }
+    if (!att.isEmpty())
+    {
+      QCString *str=VhdlDocGen::findKeyWord(att);
+      att+=" ";
+      if (str)
+        VhdlDocGen::formatString(att,ol,mdef);
+      else
+        VhdlDocGen::startFonts(att,"vhdlchar",ol);
+    }
+
+    QCString nn=arg->name;
+    nn+=": ";
+    QCString ss=arg->type.stripWhiteSpace(); //.lower();
+    QCString w=ss.stripWhiteSpace();//.upper();
+    VhdlDocGen::startFonts(nn,"vhdlchar",ol);
+    VhdlDocGen::startFonts("in ","stringliteral",ol);
+    QCString *str=VhdlDocGen::findKeyWord(ss);
+    if (str)
+      VhdlDocGen::formatString(w,ol,mdef);
+    else
+      VhdlDocGen::startFonts(w,"vhdlchar",ol);
+
+    if (arg->attrib)
+      VhdlDocGen::startFonts(arg->attrib,"vhdlchar",ol);
+
+
+    sem=TRUE;
+    ol.endBold();
+    if (len > 2)
+    {
+      ol.lineBreak();
+    }
+  }
+  ol.startBold();
+  ol.docify(" )");
+  const char *exp=mdef->excpString();
+  if (exp)
+  {
+    ol.insertMemberAlign();
+    ol.startBold();
+    ol.docify("[ ");
+    ol.docify(exp);
+    ol.docify(" ]");
+    ol.endBold();
+  }
+  ol.endBold();
+}
+
+/*!
+ * writes a process prototype to the output
+ */
+
+void VhdlDocGen::writeProcessProto(OutputList& ol,const ArgumentList* al,const MemberDef* mdef)
+{
+  if (al==0) return;
+  ArgumentListIterator ali(*al);
+  Argument *arg;
+  bool sem=FALSE;
+  ol.startBold();
+  ol.docify(" ( ");
+  for (;(arg=ali.current());++ali)
+  {
+    if (sem)
+    {
+      ol.docify(" , ");
+    }
+    QCString nn=arg->name;
+    // VhdlDocGen::startFonts(nn,"vhdlchar",ol);
+    VhdlDocGen::writeFormatString(nn,ol,mdef);
+    sem=TRUE;
+  }
+  ol.docify(" )");
+  ol.endBold();
+}
+
+
+/*!
+ * writes a function|procedure documentation to the output
+ */
+
+void VhdlDocGen::writeFuncProcDocu(
+    const MemberDef *md,
+    OutputList& ol,
+    const ArgumentList* al,
+    bool /*type*/)
+{
+   static bool optVerilog       = Config_getBool("OPTIMIZE_OUTPUT_VERILOG"); 
+
+	
+	if (al==0) return;
+  //bool sem=FALSE;
+  ol.enableAll();
+
+  ArgumentListIterator ali(*al);
+  int index=ali.count();
+  if (index==0)
+  {
+    ol.docify(" ( ) ");
+    return;
+  }
+  ol.startParameterList(TRUE);
+  //ol.startParameterName(FALSE);
+  Argument *arg;
+  bool first=TRUE;
+  for (;(arg=ali.current());++ali)
+  {
+    ol.startParameterType(first,"");
+    //   if (first) ol.writeChar('(');
+    QCString attl=arg->defval;
+    bool bGen=attl.stripPrefix("gen!");
+    if (bGen)
+      VhdlDocGen::writeFormatString(QCString("generic "),ol,md);
+
+
+    if (VhdlDocGen::isProcedure(md))
+    {
+      startFonts(arg->defval,"keywordtype",ol);
+      ol.docify(" ");
+    }
+     if(optVerilog)  
+      VerilogDocGen::adjustMemberName(arg->name);
+
+    ol.endParameterType();
+
+    ol.startParameterName(TRUE);
+    VhdlDocGen::writeFormatString(arg->name,ol,md);
+    ol.docify("  ");
+
+    if (VhdlDocGen::isProcedure(md))
+    {
+      startFonts(arg->attrib,"stringliteral",ol);
+    }
+    else if (VhdlDocGen::isVhdlFunction(md))
+    {
+      startFonts(QCString("in"),"stringliteral",ol);
+    }
+
+    ol.docify(" ");
+    ol.disable(OutputGenerator::Man);
+    ol.startEmphasis();
+    ol.enable(OutputGenerator::Man);
+    if (!VhdlDocGen::isProcess(md))
+    {
+     // startFonts(arg->type,"vhdlkeyword",ol);
+		VhdlDocGen::writeFormatString(arg->type,ol,md);
+    }
+    ol.disable(OutputGenerator::Man);
+    ol.endEmphasis();
+    ol.enable(OutputGenerator::Man);
+
+    if (--index)
+    {
+      ol.docify(" , ");
+    }
+    else
+    {
+      //    ol.docify(" ) ");
+      ol.endParameterName(TRUE,FALSE,TRUE);
+      break;
+    }
+    ol.endParameterName(FALSE,FALSE,FALSE);
+
+    //sem=TRUE;
+    first=FALSE;
+  }
+  //ol.endParameterList();
+
+} // writeDocFunProc
+
+
+
+
+QCString VhdlDocGen::convertArgumentListToString(const ArgumentList* al,bool func)
+{
+  QCString argString;
+  bool sem=FALSE;
+  ArgumentListIterator ali(*al);
+  Argument *arg;
+
+  for (;(arg=ali.current());++ali)
+  {
+    if (sem) argString.append(", ");
+    if (func)
+    {
+      argString+=arg->name;
+      argString+=":";
+      argString+=arg->type;
+    }
+    else
+    {
+      argString+=arg->defval+" ";
+      argString+=arg->name+" :";
+      argString+=arg->attrib+" ";
+      argString+=arg->type;
+    }
+    sem=TRUE;
+  }
+  return argString;
+}
+
+
+void VhdlDocGen::writeVhdlDeclarations(MemberList* ml,
+    OutputList& ol,GroupDef* gd,ClassDef* cd,FileDef *fd,NamespaceDef* nd)
+{
+  
+   static bool optVerilog  = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+  
+   if(optVerilog){
+       VerilogDocGen::writeVerilogDeclarations(ml,ol,0,cd);
+       return;   
+   }
+	
+	
+	
+  static ClassDef *cdef;
+  //static GroupDef* gdef;
+  if (cd && cdef!=cd)
+  { // only one inline link
+    VhdlDocGen::writeInlineClassLink(cd,ol);
+    cdef=cd;
+  }
+
+  /*
+     if (gd && gdef==gd) return;
+     if (gd && gdef!=gd)
+     {
+     gdef=gd;
+     }
+   */
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::LIBRARY,FALSE),0,FALSE,VhdlDocGen::LIBRARY);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::USE,FALSE),0,FALSE,VhdlDocGen::USE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::FUNCTION,FALSE),0,FALSE,VhdlDocGen::FUNCTION);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::COMPONENT,FALSE),0,FALSE,VhdlDocGen::COMPONENT);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::CONSTANT,FALSE),0,FALSE,VhdlDocGen::CONSTANT);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::TYPE,FALSE),0,FALSE,VhdlDocGen::TYPE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SUBTYPE,FALSE),0,FALSE,VhdlDocGen::SUBTYPE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::GENERIC,FALSE),0,FALSE,VhdlDocGen::GENERIC);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PORT,FALSE),0,FALSE,VhdlDocGen::PORT);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PROCESS,FALSE),0,FALSE,VhdlDocGen::PROCESS);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SIGNAL,FALSE),0,FALSE,VhdlDocGen::SIGNAL);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::ATTRIBUTE,FALSE),0,FALSE,VhdlDocGen::ATTRIBUTE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::PROCEDURE,FALSE),0,FALSE,VhdlDocGen::PROCEDURE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::RECORD,FALSE),0,FALSE,VhdlDocGen::RECORD);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::UNITS,FALSE),0,FALSE,VhdlDocGen::UNITS);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::SHAREDVARIABLE,FALSE),0,FALSE,VhdlDocGen::SHAREDVARIABLE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::VFILE,FALSE),0,FALSE,VhdlDocGen::VFILE);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::GROUP,FALSE),0,FALSE,VhdlDocGen::GROUP);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::INSTANTIATION,FALSE),0,FALSE,VhdlDocGen::INSTANTIATION);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::ALIAS,FALSE),0,FALSE,VhdlDocGen::ALIAS);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::MISCELLANEOUS),0,FALSE,VhdlDocGen::MISCELLANEOUS);
+
+  // configurations must be added to global file definitions.
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::CONFIG,FALSE),0,FALSE,VhdlDocGen::CONFIG);
+  VhdlDocGen::writeVHDLDeclarations(ml,ol,cd,nd,fd,gd,theTranslator_vhdlType(VhdlDocGen::UCF_CONST,FALSE),0,FALSE,VhdlDocGen::UCF_CONST);
+
+}
+
+static void setGlobalType(MemberList *ml)
+{
+  if (ml==0) return;
+  MemberDef *mdd=0;
+  MemberListIterator mmli(*ml);
+  for ( ; (mdd=mmli.current()); ++mmli )
+  {
+    QCString l=mdd->typeString();
+
+    if (strcmp(mdd->argsString(),"package")==0)
+    {
+ 	mdd->setMemberSpecifiers(VhdlDocGen::INSTANTIATION);
+    }
+    else if (strcmp(mdd->argsString(),"configuration")==0)
+    {
+      mdd->setMemberSpecifiers(VhdlDocGen::CONFIG);
+    }
+    else if (strcmp(mdd->typeString(),"library")==0)
+    {
+      mdd->setMemberSpecifiers(VhdlDocGen::LIBRARY);
+    }
+    else if (strcmp(mdd->typeString(),"use")==0)
+    {
+      mdd->setMemberSpecifiers(VhdlDocGen::USE);
+    }
+    else if (stricmp(mdd->typeString(),"misc")==0)
+    {
+      mdd->setMemberSpecifiers(VhdlDocGen::MISCELLANEOUS);
+    }
+    else if (stricmp(mdd->typeString(),"ucf_const")==0)
+    {
+      mdd->setMemberSpecifiers(VhdlDocGen::UCF_CONST);
+    }
+  }
+}
+
+/* writes a vhdl type documentation */
+void VhdlDocGen::writeVHDLTypeDocumentation(const MemberDef* mdef, const Definition *d, OutputList &ol)
+{
+  ClassDef *cd=(ClassDef*)d;
+ bool bParseVerilogFunc=false;
+  static bool optVerilog  = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+  if(optVerilog)
+   if(!mdef->isVariable())
+    bParseVerilogFunc=true;
+
+
+  if (cd==0) return;
+
+  QCString ttype=mdef->typeString();
+  QCString largs=mdef->argsString();
+
+  if ((VhdlDocGen::isVhdlFunction(mdef) || VhdlDocGen::isProcedure(mdef) || VhdlDocGen::isProcess(mdef) || bParseVerilogFunc))
+  {
+    QCString nn=mdef->typeString();
+    nn=nn.stripWhiteSpace();
+    QCString na=cd->name();
+    MemberDef* memdef=VhdlDocGen::findMember(na,nn);
+    if (memdef && memdef->isLinkable())
+    {
+      ol.docify(" ");
+
+      ol.startBold();
+      writeLink(memdef,ol);
+      ol.endBold();
+      ol.docify(" ");
+    }
+    else
+    {
+      ol.docify(" ");
+      VhdlDocGen::formatString(ttype,ol,mdef);
+      ol.docify(" ");
+    }
+    ol.docify(mdef->name());
+    VhdlDocGen::writeFuncProcDocu(mdef,ol, mdef->argumentList().pointer());
+  }
+
+
+  if (mdef->isVariable())
+  {
+    
+	  
+	if (VhdlDocGen::isConstraint(mdef))
+    {
+      writeLink(mdef,ol);
+      ol.docify(" ");
+
+      largs=largs.replace(QRegExp("#")," ");
+      VhdlDocGen::formatString(largs,ol,mdef);
+      return;
+    }
+    else
+    {
+      writeLink(mdef,ol);
+      if (VhdlDocGen::isLibrary(mdef) || VhdlDocGen::isPackage(mdef))
+      {
+        return;
+      }
+      ol.docify(" ");
+    }
+
+     if(optVerilog)
+      {
+       if(mdef->getMemberSpecifiers()==VerilogDocGen::FEATURE)
+   {
+	 QCString arg=mdef->getDefinition();
+	 int kr=arg.find("\\?");	  
+	 if(kr>=0)
+	 {
+       arg=arg.left(kr-2);
+	   arg.stripPrefix("feature");
+	   arg=arg.simplifyWhiteSpace();
+	   arg.stripPrefix(mdef->name().data());
+	   arg.append("{ . . . }");
+	   VhdlDocGen::formatString(arg,ol,mdef);
+	 }
+	
+	 else{
+     QCString ttype=mdef->typeString();
+	 ttype.stripPrefix("feature");
+	 VhdlDocGen::formatString(ttype,ol,mdef);
+	 }
+	 return;  
+	  }
+    }
+    // QCString largs=mdef->argsString();
+
+    bool c=largs=="context";
+    bool brec=largs.stripPrefix("record")  ;
+
+    if (!brec && !c)
+      VhdlDocGen::formatString(ttype,ol,mdef);
+
+    if (c || brec || largs.stripPrefix("units"))
+    {
+      if (c)
+	  largs=ttype;
+      VhdlDocGen::writeRecUnitDocu(mdef,ol,largs);
+      return;
+    }
+
+    ol.docify(" ");
+    if (VhdlDocGen::isPort(mdef) || VhdlDocGen::isGeneric(mdef))
+    {
+      // QCString largs=mdef->argsString();
+      VhdlDocGen::formatString(largs,ol,mdef);
+      ol.docify(" ");
+    }
+  }
+}
+
+/* writes a vhdl type declaration */
+
+void VhdlDocGen::writeVHDLDeclaration(MemberDef* mdef,OutputList &ol,
+    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
+    bool /*inGroup*/)
+{
+  static QRegExp reg("[%]");
+  LockingPtr<MemberDef> lock(mdef,mdef);
+
+  Definition *d=0;
+
+  /* some vhdl files contain only a configuration  description
+
+     library work;
+     configuration cfg_tb_jtag_gotoBackup of tb_jtag_gotoBackup is
+     for RTL
+     end for;
+     end cfg_tb_jtag_gotoBackup;
+
+     in this case library work does not belong to an entity, package ...
+
+   */
+
+  ASSERT(cd!=0 || nd!=0 || fd!=0 || gd!=0 ||
+      mdef->getMemberSpecifiers()==VhdlDocGen::LIBRARY ||
+      mdef->getMemberSpecifiers()==VhdlDocGen::USE
+      ); // member should belong to something
+  if (cd) d=cd;
+  else if (nd) d=nd;
+  else if (fd) d=fd;
+  else if (gd) d=gd;
+  else d=(Definition*)mdef;
+
+  // write tag file information of this member
+  if (!Config_getString("GENERATE_TAGFILE").isEmpty())
+  {
+    Doxygen::tagFile << "    <member kind=\"";
+    if (VhdlDocGen::isGeneric(mdef))      Doxygen::tagFile << "generic";
+    if (VhdlDocGen::isPort(mdef))         Doxygen::tagFile << "port";
+    if (VhdlDocGen::isEntity(mdef))       Doxygen::tagFile << "entity";
+    if (VhdlDocGen::isComponent(mdef))    Doxygen::tagFile << "component";
+    if (VhdlDocGen::isVType(mdef))        Doxygen::tagFile << "type";
+    if (VhdlDocGen::isConstant(mdef))     Doxygen::tagFile << "constant";
+    if (VhdlDocGen::isSubType(mdef))      Doxygen::tagFile << "subtype";
+    if (VhdlDocGen::isVhdlFunction(mdef)) Doxygen::tagFile << "function";
+    if (VhdlDocGen::isProcedure(mdef))    Doxygen::tagFile << "procedure";
+    if (VhdlDocGen::isProcess(mdef))      Doxygen::tagFile << "process";
+    if (VhdlDocGen::isSignals(mdef))      Doxygen::tagFile << "signal";
+    if (VhdlDocGen::isAttribute(mdef))    Doxygen::tagFile << "attribute";
+    if (VhdlDocGen::isRecord(mdef))       Doxygen::tagFile << "record";
+    if (VhdlDocGen::isLibrary(mdef))      Doxygen::tagFile << "library";
+    if (VhdlDocGen::isPackage(mdef))      Doxygen::tagFile << "package";
+    if (VhdlDocGen::isVariable(mdef))     Doxygen::tagFile << "shared variable";
+    if (VhdlDocGen::isFile(mdef))         Doxygen::tagFile << "file";
+    if (VhdlDocGen::isGroup(mdef))        Doxygen::tagFile << "group";
+    if (VhdlDocGen::isCompInst(mdef))     Doxygen::tagFile << " instantiation";
+    if (VhdlDocGen::isAlias(mdef))        Doxygen::tagFile << "alias";
+    if (VhdlDocGen::isCompInst(mdef))     Doxygen::tagFile << "configuration";
+
+    Doxygen::tagFile << "\">" << endl;
+    Doxygen::tagFile << "      <type>" << convertToXML(mdef->typeString()) << "</type>" << endl;
+    Doxygen::tagFile << "      <name>" << convertToXML(mdef->name()) << "</name>" << endl;
+    Doxygen::tagFile << "      <anchorfile>" << convertToXML(mdef->getOutputFileBase()+Doxygen::htmlFileExtension) << "</anchorfile>" << endl;
+    Doxygen::tagFile << "      <anchor>" << convertToXML(mdef->anchor()) << "</anchor>" << endl;
+
+    if (VhdlDocGen::isVhdlFunction(mdef))
+      Doxygen::tagFile << "      <arglist>" << convertToXML(VhdlDocGen::convertArgumentListToString(mdef->argumentList().pointer(),TRUE)) << "</arglist>" << endl;
+    else if (VhdlDocGen::isProcedure(mdef))
+      Doxygen::tagFile << "      <arglist>" << convertToXML(VhdlDocGen::convertArgumentListToString(mdef->argumentList().pointer(),FALSE)) << "</arglist>" << endl;
+    else
+      Doxygen::tagFile << "      <arglist>" << convertToXML(mdef->argsString()) << "</arglist>" << endl;
+
+    mdef->writeDocAnchorsToTagFile();
+    Doxygen::tagFile << "    </member>" << endl;
+
+  }
+
+  // write search index info
+  if (Doxygen::searchIndex)
+  {
+    Doxygen::searchIndex->setCurrentDoc(mdef->qualifiedName(),mdef->getOutputFileBase(),mdef->anchor());
+    Doxygen::searchIndex->addWord(mdef->localName(),TRUE);
+    Doxygen::searchIndex->addWord(mdef->qualifiedName(),FALSE);
+  }
+
+  QCString cname  = d->name();
+  QCString cfname = d->getOutputFileBase();
+
+  //HtmlHelp *htmlHelp=0;
+  //  bool hasHtmlHelp = Config_getBool("GENERATE_HTML") && Config_getBool("GENERATE_HTMLHELP");
+  //  if (hasHtmlHelp) htmlHelp = HtmlHelp::getInstance();
+
+  // search for the last anonymous scope in the member type
+  ClassDef *annoClassDef=mdef->getClassDefOfAnonymousType();
+
+  // start a new member declaration
+  bool isAnonymous = annoClassDef; // || m_impl->annMemb || m_impl->annEnumType;
+  ///printf("startMemberItem for %s\n",name().data());
+  ol.startMemberItem( mdef->anchor(), isAnonymous ); //? 1 : m_impl->tArgList ? 3 : 0);
+
+  // If there is no detailed description we need to write the anchor here.
+  bool detailsVisible = mdef->isDetailedSectionLinkable();
+  if (!detailsVisible) // && !m_impl->annMemb)
+  {
+    QCString doxyName=mdef->name().copy();
+    if (!cname.isEmpty()) doxyName.prepend(cname+"::");
+    QCString doxyArgs=mdef->argsString();
+    ol.startDoxyAnchor(cfname,cname,mdef->anchor(),doxyName,doxyArgs);
+
+    ol.pushGeneratorState();
+    ol.disable(OutputGenerator::Man);
+    ol.disable(OutputGenerator::Latex);
+    ol.docify("\n");
+    ol.popGeneratorState();
+
+  }
+  // *** write type
+  /*VHDL CHANGE */
+  bool bRec,bUnit;
+  QCString ltype(mdef->typeString());
+  ltype=ltype.replace(reg," ");
+  QCString largs(mdef->argsString());
+  largs=largs.replace(reg," ");
+  int mm=mdef->getMemberSpecifiers();
+  mdef->setType(ltype.data());
+  mdef->setArgsString(largs.data());
+  //ClassDef * plo=mdef->getClassDef();
+  ClassDef *kl=0;
+  LockingPtr<ArgumentList> alp = mdef->argumentList();
+  QCString nn;
+  //VhdlDocGen::adjustRecordMember(mdef);
+  if (gd) gd=0;
+  switch(mm)
+  {
+    case VhdlDocGen::MISCELLANEOUS:
+      VhdlDocGen::writeCodeFragment(mdef,ol);
+      break;
+    case VhdlDocGen::PROCEDURE:
+    case VhdlDocGen::FUNCTION:
+      ol.startBold();
+      VhdlDocGen::formatString(ltype,ol,mdef);
+      ol.endBold();
+      ol.insertMemberAlign();
+      ol.docify(" ");
+
+      writeLink(mdef,ol);
+      if (alp!=0 && mm==VhdlDocGen::FUNCTION)
+        VhdlDocGen::writeFunctionProto(ol,alp.pointer(),mdef);
+
+      if (alp!=0 && mm==VhdlDocGen::PROCEDURE)
+        VhdlDocGen::writeProcedureProto(ol,alp.pointer(),mdef);
+
+      break;
+    case VhdlDocGen::USE:
+      kl=VhdlDocGen::getClass(mdef->name());
+      if (kl && ((VhdlDocGen::VhdlClasses)kl->protection()==VhdlDocGen::ENTITYCLASS)) break;
+      writeLink(mdef,ol);
+      ol.insertMemberAlign();
+      ol.docify("  ");
+
+      if (kl)
+      {
+        nn=kl->getOutputFileBase();
+        ol.pushGeneratorState();
+        ol.disableAllBut(OutputGenerator::Html);
+        ol.docify(" ");
+        QCString name=theTranslator_vhdlType(VhdlDocGen::PACKAGE,TRUE);
+        ol.startBold();
+        ol.docify(name.data());
+        name.resize(0);
+        ol.endBold();
+        name+=" <"+mdef->name()+">";
+        ol.startEmphasis();
+        ol.writeObjectLink(kl->getReference(),kl->getOutputFileBase(),0,name.data());
+        ol.popGeneratorState();
+      }
+      break;
+    case VhdlDocGen::LIBRARY:
+      writeLink(mdef,ol);
+      ol.insertMemberAlign();
+     if (largs=="context")
+     {
+	VhdlDocGen::writeRecorUnit(ltype,ol,mdef);
+     }
+
+     break;
+
+    case VhdlDocGen::GENERIC:
+    case VhdlDocGen::PORT:
+    case VhdlDocGen::ALIAS:
+
+      writeLink(mdef,ol);
+      ol.docify(" ");
+      ol.insertMemberAlign();
+      if (mm==VhdlDocGen::GENERIC)
+      {
+        ol.startBold();
+        VhdlDocGen::formatString(largs,ol,mdef);
+        ol.endBold();
+      }
+      else
+      {
+        ol.docify(" ");
+        ol.startBold();
+        VhdlDocGen::formatString(ltype,ol,mdef);
+        ol.endBold();
+        ol.docify(" ");
+        VhdlDocGen::formatString(largs,ol,mdef);
+      }
+      break;
+    case VhdlDocGen::PROCESS:
+      writeLink(mdef,ol);
+      ol.insertMemberAlign();
+      VhdlDocGen::writeProcessProto(ol,alp.pointer(),mdef);
+      break;
+    case VhdlDocGen::PACKAGE:
+    case VhdlDocGen::ENTITY:
+    case VhdlDocGen::COMPONENT:
+    case VhdlDocGen::INSTANTIATION:
+    case VhdlDocGen::CONFIG:
+      if (VhdlDocGen::isCompInst(mdef) )
+      {
+        nn=largs;
+        if(nn.stripPrefix("function") || nn.stripPrefix("package"))
+        {
+          VhdlDocGen::formatString(largs,ol,mdef);
+          ol.insertMemberAlign();
+          writeLink(mdef,ol);
+          ol.docify(" ");
+          VhdlDocGen::formatString(ltype,ol,mdef);
+          break;
+        }
+
+        largs.prepend("::");
+        largs.prepend(mdef->name().data());
+        ol.writeObjectLink(mdef->getReference(),
+            cfname,
+            mdef->anchor(),
+            mdef->name());
+      }
+      else
+        writeLink(mdef,ol);
+
+      ol.insertMemberAlign();
+      ol.docify("  ");
+
+      ol.startBold();
+      ol.docify(ltype);
+      ol.endBold();
+      ol.docify("  ");
+      if (VhdlDocGen::isComponent(mdef) ||
+          VhdlDocGen::isConfig(mdef)    ||
+          VhdlDocGen::isCompInst(mdef))
+      {
+        if (VhdlDocGen::isConfig(mdef) || VhdlDocGen::isCompInst(mdef))
+        {
+          nn=mdef->getOutputFileBase();
+          nn=ltype;
+        }
+        else
+        {
+          nn=mdef->name();
+        }
+        kl=getClass(nn.data());
+        if (kl)
+        {
+          nn=kl->getOutputFileBase();
+          ol.pushGeneratorState();
+          ol.disableAllBut(OutputGenerator::Html);
+          ol.startEmphasis();
+          QCString name("<Entity ");
+          if (VhdlDocGen::isConfig(mdef) || VhdlDocGen::isCompInst(mdef))
+          {
+            name+=ltype+">";
+          }
+          else
+          {
+            name+=mdef->name()+"> ";
+          }
+          ol.writeObjectLink(kl->getReference(),kl->getOutputFileBase(),0,name.data());
+          ol.endEmphasis();
+          ol.popGeneratorState();
+        }
+      }
+      break;
+    case VhdlDocGen::UCF_CONST:
+      mm=mdef->name().findRev('_');
+      if (mm>0)
+      {
+        mdef->setName(mdef->name().left(mm));
+      }
+	  VhdlDocGen::writeUCFLink(mdef,ol);
+      break;
+    case VhdlDocGen::SIGNAL:
+    case VhdlDocGen::ATTRIBUTE:
+    case VhdlDocGen::SUBTYPE:
+    case VhdlDocGen::CONSTANT:
+    case VhdlDocGen::SHAREDVARIABLE:
+    case VhdlDocGen::VFILE:
+    case VhdlDocGen::GROUP:
+      writeLink(mdef,ol);
+      ol.docify(" ");
+      ol.insertMemberAlign();
+      VhdlDocGen::formatString(ltype,ol,mdef);
+      break;
+    case VhdlDocGen::TYPE:
+      bRec=largs.stripPrefix("record") ;
+      bUnit=largs.stripPrefix("units") ;
+      ol.startBold();
+      if (bRec)
+        ol.docify("record: ");
+      if (bUnit)
+        ol.docify("units: ");
+      writeLink(mdef,ol);
+      ol.insertMemberAlign();
+      if (!bRec)
+        VhdlDocGen::formatString(ltype,ol,mdef);
+      if (bUnit) ol.lineBreak();
+      if (bRec || bUnit)
+        writeRecorUnit(largs,ol,mdef);
+      ol.endBold();
+      break;
+
+    default: break;
+  }
+
+  bool htmlOn = ol.isEnabled(OutputGenerator::Html);
+  if (htmlOn && /*Config_getBool("HTML_ALIGN_MEMBERS") &&*/ !ltype.isEmpty())
+  {
+    ol.disable(OutputGenerator::Html);
+  }
+  if (!ltype.isEmpty()) ol.docify(" ");
+
+  if (htmlOn)
+  {
+    ol.enable(OutputGenerator::Html);
+  }
+
+  if (!detailsVisible)// && !m_impl->annMemb)
+  {
+    ol.endDoxyAnchor(cfname,mdef->anchor());
+  }
+
+  //printf("endMember %s annoClassDef=%p annEnumType=%p\n",
+  //    name().data(),annoClassDef,annEnumType);
+  ol.endMemberItem();
+  if (!mdef->briefDescription().isEmpty() &&   Config_getBool("BRIEF_MEMBER_DESC") /* && !annMemb */)
+  {
+    ol.startMemberDescription(mdef->anchor());
+    ol.parseDoc(mdef->briefFile(),mdef->briefLine(),
+        mdef->getOuterScope()?mdef->getOuterScope():d,
+        mdef,mdef->briefDescription(),TRUE,FALSE,0,TRUE,FALSE);
+    if (detailsVisible)
+    {
+      ol.pushGeneratorState();
+      ol.disableAllBut(OutputGenerator::Html);
+      //ol.endEmphasis();
+      ol.docify(" ");
+      if (mdef->getGroupDef()!=0 && gd==0) // forward link to the group
+      {
+        ol.startTextLink(mdef->getOutputFileBase(),mdef->anchor());
+      }
+      else // local link
+      {
+        ol.startTextLink(0,mdef->anchor());
+      }
+      ol.endTextLink();
+      //ol.startEmphasis();
+      ol.popGeneratorState();
+    }
+    //ol.newParagraph();
+    ol.endMemberDescription();
+  }
+  mdef->warnIfUndocumented();
+
+}// end writeVhdlDeclaration
+
+
+void VhdlDocGen::writeLink(const MemberDef* mdef,OutputList &ol)
+{
+  ol.writeObjectLink(mdef->getReference(),
+      mdef->getOutputFileBase(),
+      mdef->anchor(),
+      mdef->name());
+}
+
+void VhdlDocGen::writePlainVHDLDeclarations(
+    MemberList* mlist,OutputList &ol,
+    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,int specifier)
+{
+
+  SDict<QCString> pack(1009);
+
+  ol.pushGeneratorState();
+
+  bool first=TRUE;
+  MemberDef *md;
+  MemberListIterator mli(*mlist);
+  for ( ; (md=mli.current()); ++mli )
+  {
+    int mems=md->getMemberSpecifiers();
+    if (md->isBriefSectionVisible() && (mems==specifier) && (mems!=VhdlDocGen::LIBRARY) )
+    {
+      if (first) {ol.startMemberList();first=FALSE;}
+      VhdlDocGen::writeVHDLDeclaration(md,ol,cd,nd,fd,gd,FALSE);
+    } //if
+    else if (md->isBriefSectionVisible() && (mems==specifier))
+    {
+      if (!pack.find(md->name().data()))
+      {
+        if (first) ol.startMemberList(),first=FALSE;
+        VhdlDocGen::writeVHDLDeclaration(md,ol,cd,nd,fd,gd,FALSE);
+        pack.append(md->name().data(),new QCString(md->name().data()));
+      }
+    } //if
+  } //for
+  if (!first) ol.endMemberList();
+  pack.clear();
+}//plainDeclaration
+
+bool VhdlDocGen::membersHaveSpecificType(MemberList *ml,int type)
+{
+  if (ml==0) return FALSE;
+  MemberDef *mdd=0;
+  MemberListIterator mmli(*ml);
+  for ( ; (mdd=mmli.current()); ++mmli )
+  {
+    if (mdd->getMemberSpecifiers()==type) //is type in class
+    {
+      return TRUE;
+    }
+  }
+  if (ml->getMemberGroupList())
+  {
+    MemberGroupListIterator mgli(*ml->getMemberGroupList());
+    MemberGroup *mg;
+    while ((mg=mgli.current()))
+    {
+      if (mg->members())
+      {
+        if (membersHaveSpecificType(mg->members(),type)) return TRUE;
+      }
+      ++mgli;
+    }
+  }
+  return FALSE;
+}
+
+void VhdlDocGen::writeVHDLDeclarations(MemberList* ml,OutputList &ol,
+    ClassDef *cd,NamespaceDef *nd,FileDef *fd,GroupDef *gd,
+    const char *title,const char *subtitle,bool /*showEnumValues*/,int type)
+{
+  setGlobalType(ml);
+  if (!membersHaveSpecificType(ml,type)) return;
+
+  if (title)
+  {
+    ol.startMemberHeader(title);
+    ol.parseText(title);
+    ol.endMemberHeader();
+    ol.docify(" ");
+  }
+  if (subtitle && subtitle[0]!=0)
+  {
+    ol.startMemberSubtitle();
+    ol.parseDoc("[generated]",-1,0,0,subtitle,FALSE,FALSE,0,TRUE,FALSE);
+    ol.endMemberSubtitle();
+  } //printf("memberGroupList=%p\n",memberGroupList);
+
+  VhdlDocGen::writePlainVHDLDeclarations(ml,ol,cd,nd,fd,gd,type);
+
+  if (ml->getMemberGroupList())
+  {
+    MemberGroupListIterator mgli(*ml->getMemberGroupList());
+    MemberGroup *mg;
+    while ((mg=mgli.current()))
+    {
+      if (membersHaveSpecificType(mg->members(),type))
+      {
+        //printf("mg->header=%s\n",mg->header().data());
+        bool hasHeader=mg->header()!="[NOHEADER]";
+        ol.startMemberGroupHeader(hasHeader);
+        if (hasHeader)
+        {
+          ol.parseText(mg->header());
+        }
+        ol.endMemberGroupHeader();
+        if (!mg->documentation().isEmpty())
+        {
+          //printf("Member group has docs!\n");
+          ol.startMemberGroupDocs();
+          ol.parseDoc("[generated]",-1,0,0,mg->documentation()+"\n",FALSE,FALSE);
+          ol.endMemberGroupDocs();
+        }
+        ol.startMemberGroup();
+        //printf("--- mg->writePlainDeclarations ---\n");
+        VhdlDocGen::writePlainVHDLDeclarations(mg->members(),ol,cd,nd,fd,gd,type);
+        ol.endMemberGroup(hasHeader);
+      }
+      ++mgli;
+    }
+  }
+}// writeVHDLDeclarations
+
+
+/* strips the prefix for record and unit members*/
+void VhdlDocGen::adjustRecordMember(MemberDef *mdef)
+{ //,OutputList & ol) {
+  QRegExp regg("[_a-zA-Z\"]");
+  QCString nn=mdef->name();
+  int j=nn.find(regg,0);
+  if (j>0)
+  {
+    nn=nn.mid(j,nn.length());
+    mdef->setName(nn.data());
+  }
+}//adjustRecordMember
+
+/* strips the prefix for package and package body */
+
+bool VhdlDocGen::writeClassType( ClassDef *& cd,
+    OutputList &ol ,QCString & cname)
+{
+  //static ClassDef *prev = 0;
+  //if (prev == cd)  return TRUE;
+  //if (cd != prev) prev=cd;
+
+  static bool optVerilog    = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
+  QCString qcs;
+  if(optVerilog){
+   if(cd->protection()==Public)
+    qcs+=" Module";
+     else
+    qcs+=" Primitive";
+  }
+  else{
+   int id=cd->protection();
+   qcs = VhdlDocGen::trTypeString(id+2);
+}
+   cname=VhdlDocGen::getClassName(cd);
+  ol.startBold();
+  ol.writeString(qcs.data());
+  ol.writeString(" ");
+  ol.endBold();
+  //ol.insertMemberAlign();
+  return FALSE;
+}// writeClassLink
+
+QCString VhdlDocGen::trVhdlType(int type,bool sing)
+{
+  
+  static bool optVerilog    = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+ 
+   if(optVerilog) return   VerilogDocGen::convertTypeToString(type,sing);
+
+	 
+  switch(type)
+  {
+    case VhdlDocGen::LIBRARY:
+      if (sing) return "Library";
+      else      return "Libraries";
+    case VhdlDocGen::PACKAGE:
+      if (sing) return "Package";
+      else      return "Packages";
+    case VhdlDocGen::SIGNAL:
+      if (sing) return "Signal";
+      else      return "Signals";
+    case VhdlDocGen::COMPONENT:
+      if (sing) return "Component";
+      else      return "Components";
+    case VhdlDocGen::CONSTANT:
+      if (sing) return "Constant";
+      else      return "Constants";
+    case VhdlDocGen::ENTITY:
+      if (sing) return "Entity";
+      else      return "Entities";
+    case VhdlDocGen::TYPE:
+      if (sing) return "Type";
+      else      return "Types";
+    case VhdlDocGen::SUBTYPE:
+      if (sing) return "Subtype";
+      else      return "Subtypes";
+    case VhdlDocGen::FUNCTION:
+      if (sing) return "Function";
+      else      return "Functions";
+    case VhdlDocGen::RECORD:
+      if (sing) return "Record";
+      else      return "Records";
+    case VhdlDocGen::PROCEDURE:
+      if (sing) return "Procedure";
+      else      return "Procedures";
+    case VhdlDocGen::ARCHITECTURE:
+      if (sing) return "Architecture";
+      else      return "Architectures";
+    case VhdlDocGen::ATTRIBUTE:
+      if (sing) return "Attribute";
+      else      return "Attributes";
+    case VhdlDocGen::PROCESS:
+      if (sing) return "Process";
+      else      return "Processes";
+    case VhdlDocGen::PORT:
+      if (sing) return "Port";
+      else      return "Ports";
+    case VhdlDocGen::USE:
+      if (sing) return "use clause";
+      else      return "Use Clauses";
+    case VhdlDocGen::GENERIC:
+      if (sing) return "Generic";
+      else      return "Generics";
+    case VhdlDocGen::PACKAGE_BODY:
+      return "Package Body";
+    case VhdlDocGen::UNITS:
+      return "Units";
+    case VhdlDocGen::SHAREDVARIABLE:
+      if (sing) return "Shared Variable";
+      return "Shared Variables";
+    case VhdlDocGen::VFILE:
+      if (sing) return "File";
+      return "Files";
+    case VhdlDocGen::GROUP:
+      if (sing) return "Group";
+      return "Groups";
+    case VhdlDocGen::INSTANTIATION:
+      if (sing) return "Instantiation";
+      else      return "Instantiations";
+    case VhdlDocGen::ALIAS:
+      if (sing) return "Alias";
+      return "Aliases";
+    case VhdlDocGen::CONFIG:
+      if (sing) return "Configuration";
+      return "Configurations";
+    case VhdlDocGen::MISCELLANEOUS:
+      return "Miscellaneous";
+    case VhdlDocGen::UCF_CONST:
+      return "Constraints";
+    default:
+      return "Class";
+  }
+}
+
+QCString VhdlDocGen::trDesignUnitHierarchy()
+{
+  return "Design Unit Hierarchy";
+}
+
+QCString VhdlDocGen::trDesignUnitList()
+{
+  return "Design Unit List";
+}
+
+QCString VhdlDocGen::trDesignUnitMembers()
+{
+  return "Design Unit Members";
+}
+
+QCString VhdlDocGen::trDesignUnitListDescription()
+{
+  
+	 static bool optVerilog = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+ if(optVerilog)
+  return "Here is a list of all design unit members with links to "
+         "the Modules they belong to:";
+
+	
+	return "Here is a list of all design unit members with links to "
+    "the Entities  they belong to:";
+}
+
+QCString VhdlDocGen::trDesignUnitIndex()
+{
+  return "Design Unit Index";
+}
+
+QCString VhdlDocGen::trDesignUnits()
+{
+  return "Design Units";
+}
+
+QCString VhdlDocGen::trFunctionAndProc()
+{
+  
+	 if(Config_getBool("OPTIMIZE_OUTPUT_VERILOG"))
+   return "Functions/Tasks/Always Construct";
+
+	return "Functions/Procedures/Processes";
+}
+
+
+
+
+
+/* do not insert the same component twice */
+
+bool VhdlDocGen::foundInsertedComponent(const QCString & name,Entry* root)
+{
+  QListIterator<BaseInfo> bii(*root->extends);
+  BaseInfo *bi=0;
+  for (bii.toFirst();(bi=bii.current());++bii)
+  {
+    if (bi->name==name)
+    {
+      return TRUE; //
+    }
+  }
+
+  return FALSE;
+}// found component
+
+/*! writes a link if the string is linkable else a formatted string */
+
+void VhdlDocGen::writeStringLink(const MemberDef *mdef,QCString mem, OutputList& ol)
+{
+  
+   bool optVerilog          = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+       MemberDef* memdef=0;
+ 
+
+	
+  if (mdef)
+  {
+    ClassDef *cd=mdef->getClassDef();
+    if (cd)
+    {
+      QCString n=cd->name();
+       if(optVerilog){
+        if(mem.contains("`"))
+        memdef = findGlobalMember(mem);
+        if(memdef==0)
+        memdef=VerilogDocGen::findMember(n,mem,-1);
+      }
+      else
+     memdef=VhdlDocGen::findMember(n,mem);
+      
+      if (memdef && memdef->isLinkable())
+      {
+        ol.startBold();
+        writeLink(memdef,ol);
+        ol.endBold();
+        ol.docify(" ");
+        return;
+      }
+    }
+  }
+  VhdlDocGen::startFonts(mem,"vhdlchar",ol);
+}// found component
+
+void VhdlDocGen::writeCodeFragment( MemberDef *mdef,OutputList& ol)
+{
+  //  Definition d=(Definition)mdef;
+  //	QCString fdd=mdef->getDefFileExtension();
+  //	QCString scope=mdef->getScopeString();
+  QCString codeFragment=mdef->documentation();
+  //FileDef *fd=mdef->getFileDef();
+
+  //int start=mdef->getStartBodyLine();
+  //int end=mdef->getEndBodyLine();
+  QStringList qsl=QStringList::split("\n",codeFragment);
+  writeLink(mdef,ol);
+  ol.docify(" ");
+  ol.insertMemberAlign();
+  int len= qsl.count();
+  for(int j=0;j<len;j++)
+  {
+    QCString q=qsl[j].utf8();
+    VhdlDocGen::writeFormatString(q,ol,mdef);
+    ol.lineBreak();
+    if (j==2) // only the first three lines are shown
+    {
+      q = "...";
+      VhdlDocGen::writeFormatString(q,ol,mdef);
+      break;
+    }
+  }
+}
+
+void VhdlDocGen::writeSource(MemberDef *mdef,OutputList& ol,QCString & cname)
+{
+  QCString codeFragment=mdef->documentation();
+  int start=mdef->getStartBodyLine();
+  QStringList qsl=QStringList::split("\n",codeFragment);
+  ol.startCodeFragment();
+  int len = qsl.count();
+  QCString lineNumber;
+  int j;
+  for (j=0;j<len;j++)
+  {
+    lineNumber.sprintf("%05d",start++);
+    lineNumber+=" ";
+    ol.startBold();
+    ol.docify(lineNumber.data());
+    ol.endBold();
+    ol.insertMemberAlign();
+    QCString q=qsl[j].utf8();
+    VhdlDocGen::writeFormatString(q,ol,mdef);
+	ol.lineBreak();
+  }
+  ol.endCodeFragment();
+
+  mdef->writeSourceDef(ol,cname);
+  mdef->writeSourceRefs(ol,cname);
+  mdef->writeSourceReffedBy(ol,cname);
+}
+
+
+QCString VhdlDocGen::convertFileNameToClassName(QCString name)
+{
+
+  QCString n=name;
+  n=n.remove(0,6);
+
+  int i=0;
+
+  while((i=n.find("__"))>0)
+  {
+    n=n.remove(i,1);
+  }
+
+  while((i=n.find("_1"))>0)
+  {
+    n=n.replace(i,2,":");
+  }
+
+  return n;
+}
+
+void VhdlDocGen::parseUCF(const char*  input,  Entry* entity,QCString fileName,bool altera)
+{
+  QCString ucFile(input);
+  int lineNo=0;
+  QCString newLine="\n";
+  QCString comment("#!");
+  QCString brief;
+
+  while(!ucFile.isEmpty())
+  {
+    int i=ucFile.find("\n");
+    if (i<0) break;
+    lineNo++;
+    QCString temp=ucFile.left(i);
+    temp=temp.stripWhiteSpace();
+    bool bb=temp.stripPrefix("//");
+
+    if (!temp.isEmpty())
+    {
+      if (temp.stripPrefix(comment) )
+      {
+        brief+=temp;
+        brief.append("\\n");
+      }
+      else if (!temp.stripPrefix("#") && !bb)
+      {
+        if (altera)
+        {
+          int i=temp.find("-name");
+          if (i>0)
+            temp=temp.remove(0,i+5);
+
+          temp.stripPrefix("set_location_assignment");
+
+          initUCF(entity,0,temp,lineNo,fileName,brief);
+        }
+        else
+        {
+          QRegExp ee("[\\s=]");
+          int i=temp.find(ee);
+          QCString ff=temp.left(i);
+          temp.stripPrefix(ff.data());
+          ff.append("#");
+          if (!temp.isEmpty())
+          {
+            initUCF(entity,ff.data(),temp,lineNo,fileName,brief);
+          }
+        }
+      }
+    }//temp
+
+    ucFile=ucFile.remove(0,i+1);
+  }// while
+}
+
+static void initUCF(Entry* root,const char*  type,QCString &  qcs,int line,QCString & fileName,QCString & brief)
+{
+  if (qcs.isEmpty())return;
+  QRegExp sp("\\s");
+  QRegExp reg("[\\s=]");
+  QCString n;
+  // bool bo=(stricmp(type,qcs.data())==0);
+
+  VhdlDocGen::deleteAllChars(qcs,';');
+  qcs=qcs.stripWhiteSpace();
+
+  int i= qcs.find(reg);
+  if (i<0) return;
+  if (i==0)
+  {
+    n=type;
+    VhdlDocGen::deleteAllChars(n,'#');
+    type="";
+  }
+  else
+  {
+    n=qcs.left(i);
+  }
+  qcs=qcs.remove(0,i+1);
+  //  qcs.prepend("|");
+
+  qcs.stripPrefix("=");
+
+  Entry* current=new Entry;
+  current->spec=VhdlDocGen::UCF_CONST;
+  current->section=Entry::VARIABLE_SEC;
+  current->bodyLine=line;
+  current->fileName=fileName;
+  current->type="ucf_const";
+  //if (!bo)
+  //current->args=type;
+  current->args+=qcs;
+  current->lang=  SrcLangExt_VHDL ;
+
+  // adding dummy name for constraints like VOLTAGE=5,TEMPERATURE=20 C
+  if (n.isEmpty())
+  {
+    n="dummy";
+    n+=VhdlDocGen::getRecordNumber();
+  }
+
+  current->name= n+"_";
+  current->name.append(VhdlDocGen::getRecordNumber().data());
+
+  if (!brief.isEmpty())
+  {
+    current->brief=brief;
+    current->briefLine=line;
+    current->briefFile=fileName;
+    brief.resize(0);
+  }
+
+  root->addSubEntry(current);
+}
+
+
+ void VhdlDocGen::writeUCFLink(const MemberDef* mdef,OutputList &ol)
+{
+
+  QCString largs(mdef->argsString());
+  QCString n= VhdlDocGen::splitString(largs, '#');
+  // VhdlDocGen::adjustRecordMember(mdef);
+  bool equ=(n.length()==largs.length());
+
+  if (!equ)
+  {
+    ol.writeString(n.data());
+    ol.docify(" ");
+    ol.insertMemberAlign();
+  }
+
+  if (mdef->name().contains("dummy")==0)
+    VhdlDocGen::writeLink(mdef,ol);
+  if (equ)
+    ol.insertMemberAlign();
+  ol.docify(" ");
+  VhdlDocGen::formatString(largs,ol,mdef);
+}
+
+QCString VhdlDocGen::splitString(QCString& str,  char c)
+{
+  QCString n=str;
+  int i=str.find(c);
+  if (i>0)
+  {
+    n=str.left(i);
+    str=str.remove(0,i+1);
+  }
+  return n;
+}
+
+bool VhdlDocGen::findConstraintFile(LayoutNavEntry *lne)
+{
+  FileName *fn=Doxygen::inputNameList->first();
+  //LayoutNavEntry *cc = LayoutDocManager::instance().rootNavEntry()->find(LayoutNavEntry::Files);
+
+  LayoutNavEntry *kk = lne->parent();//   find(LayoutNavEntry::Files);
+  // LayoutNavEntry *kks = kk->parent();//   find(LayoutNavEntry::Files);
+  QCString file;
+  QCString co("Constraints");
+
+ if(Config_getBool("HAVE_DOT"))
+  {
+     QCString ov("Design Overview");
+	 QCString ofile("vhdl_design_overview");
+	 LayoutNavEntry *oo=new LayoutNavEntry( lne,LayoutNavEntry::MainPage,true,ofile,ov,"");  
+     kk->addChild(oo); 
+  }
+
+  while (fn)
+  {
+    FileDef *fd=fn->first();
+    if (fd->name().contains(".ucf") || fd->name().contains(".qsf"))
+    {
+      file = convertNameToFile(fd->name().data(),FALSE,FALSE);
+      LayoutNavEntry *ucf=new LayoutNavEntry(lne,LayoutNavEntry::MainPage,TRUE,file,co,"");
+      kk->addChild(ucf);
+      break;
+    }
+    fn=Doxygen::inputNameList->next();
+  }
+  return  FALSE;
+}
+
+void VhdlDocGen::writeAlphbeticalClass(OutputList& ol,const ClassDef* cd,const QCString & cname)
+{
+  if (cname.contains("::")==0)
+  {
+    ClassDef*oo=	VhdlDocGen::findArchitecture(cd);
+    ol.writeObjectLink(cd->getReference(),
+        cd->getOutputFileBase(),0,cname);
+    if (oo)
+    {
+      ol.docify(" [");
+      ol.writeObjectLink(oo->getReference(),
+          oo->getOutputFileBase(),0,"arch");
+      ol.docify("] ");
+    }
+  }
+}
+
+
+
+
+//        for cell_inst : [entity] work.proto [ (label|expr) ]
+QCString  VhdlDocGen::parseForConfig(QCString & entity,QCString & arch)
+{
+  int index;
+  QCString label;
+  QCString ent("entity");
+  if (!entity.contains(":")) return "";
+
+  QRegExp exp("[:()\\s]");
+  QStringList ql=QStringList::split(exp,entity,FALSE);
+  //int ii=ql.findIndex(ent);
+  assert(ql.count()>=2);
+  label = ql[0].utf8();
+  entity = ql[1].utf8();
+  if ((index=entity.findRev("."))>=0)
+  {
+    entity.remove(0,index+1);
+  }
+
+  if (ql.count()==3)
+  {
+    arch= ql[2].utf8();
+    ql=QStringList::split(exp,arch,FALSE);
+    if (ql.count()>1) // expression
+      arch="";
+  }
+  return label; // label
+}
+
+
+//        use (configuration|entity|open) work.test [(cellfor)];
+
+QCString  VhdlDocGen::parseForBinding(QCString & entity,QCString & arch)
+{
+  int index;
+  QRegExp exp("[()\\s]");
+
+  QCString label="";
+  QStringList ql=QStringList::split(exp,entity,FALSE);
+
+  if (ql.contains("open"))
+    return "open";
+
+  label=ql[0].utf8();
+
+  entity = ql[1].utf8();
+  if ((index=entity.findRev("."))>=0)
+    entity.remove(0,index+1);
+
+  if (ql.count()==3)
+    arch=ql[2].utf8();
+  return label;
+}
+
+ClassDef*  VhdlDocGen::findArchitecture(QCString identifier, QCString entity_name)
+{
+  QCString archName=entity_name+"::"+identifier;
+  return  Doxygen::classSDict->find(archName.data());
+}
+
+
+//@param arch bit0:flipflop
+//@param binding  e.g entity work.foo(bar)
+//@param label  |label0|label1
+//                          label0:architecture name
+//@param confVhdl of configuration file (identifier::entity_name) or
+//               the architecture if isInlineConf TRUE
+//@param isInlineConf
+//@param confN List of configurations
+
+void assignBinding(ConfNode * conf,QCString label)
+{
+  QList<Entry> instList= getVhdlInstList();
+  QListIterator<Entry> eli(instList);
+  Entry *cur;
+  ClassDef *archClass;
+  QCString archName,entityName;
+  bool allOthers=FALSE;
+
+  if (conf->isInlineConf)
+  {
+    archClass=Doxygen::classSDict->find(conf->confVhdl.data());
+  }
+  else
+  {
+    archName= VhdlDocGen::getIndexWord(label.data(),0);
+    entityName= VhdlDocGen::getIndexWord(conf->confVhdl.data(),1);
+    archClass=VhdlDocGen::findArchitecture(archName,entityName);
+  }
+
+  if (!archClass)
+  {
+    fprintf(stderr,"\n architecture %s not found ! ",conf->confVhdl.data());
+    return;
+  }
+
+  archName=archClass->name();
+
+  QCString allOt=VhdlDocGen::getIndexWord(conf->arch.data(),0);
+
+  if (allOt=="all" || allOt=="others")
+    allOthers=TRUE;
+
+  for (;(cur=eli.current());++eli)
+  {
+    if (conf->isInlineConf &&  (conf->confVhdl!=cur->args))
+      continue;
+
+    if (!conf->isInlineConf &&  (archName!=cur->args))
+      continue;
+
+    if (cur->exception==label || conf->isInlineConf)
+    {
+      QCString sign,archy;
+
+      if (allOthers==FALSE)
+      {
+        archy=conf->arch;
+        sign=cur->name+":"+cur->type;
+      }
+      else
+      {
+        sign=cur->type;
+        archy=VhdlDocGen::getIndexWord(conf->arch.data(),1);
+      }
+
+
+      if (archy==sign && !cur->stat)
+      {
+        // fprintf(stderr," \n label [%s] [%s] [%s]",cur->exception.data(),cur->type.data(),cur->name.data());
+        QCString ent1=conf->binding;
+        QCString arch1;
+        QCString rr=VhdlDocGen::parseForBinding(ent1,arch1);
+        arch1=ent1+"::"+arch1;
+        //ClassDef *archBind=Doxygen::classSDict->find(arch1.data());
+        ClassDef *ent=Doxygen::classSDict->find(ent1.data());
+        QCString	  inst=VhdlDocGen::getIndexWord(cur->args.data(),0);
+        ClassDef *cd=Doxygen::classSDict->find(inst.data());
+
+        if (cd==0 || ent==0)
+          continue;
+
+        addInstance(ent,archClass,cd,cur);
+        cur->stat=TRUE;
+      }
+    }
+  }//for
+}//assignBinding
+
+
+void assignConfiguration(ConfNode* rootNode,QCString label)
+{
+  if (rootNode==NULL) return;
+  uint iter;
+
+  if (!rootNode->isBinding())
+  {
+    //   printf("\n ARCH %s  BIND %s \n",rootNode->arch.data(),rootNode->binding.data());
+    assignBinding(rootNode,label);
+    return;
+  }
+  else
+    label+="|"+rootNode->arch;
+
+
+  for(iter=0;iter<rootNode->confN.count();iter++)
+  {
+    ConfNode* conf= (ConfNode *)rootNode->confN.at(iter);
+    assignConfiguration(conf,label);
+  }
+}
+
+/*
+
+// file foo.vhd
+// enitity foo
+//        .....
+// end entity
+
+// file foo_arch.vhd
+// architecture xxx of foo is
+//          ........
+//  end architecture
+
+ */
+void VhdlDocGen::computeVhdlComponentRelations()
+{
+
+  QCString entity,inst,arch,vhd;
+
+  QList<ConfNode> confList =  getVhdlConfiguration();
+  for (uint iter=0;iter<confList.count(); iter++)
+  {
+    ConfNode* conf= (ConfNode *)confList.at(iter);
+    assignConfiguration(conf,"");
+  }
+
+  QList<Entry> qsl= getVhdlInstList();
+  QListIterator<Entry> eli(qsl);
+  Entry *cur;
+
+  for (eli.toFirst();(cur=eli.current());++eli)
+  {
+    if (cur->stat ) //  was bind
+      continue;
+
+    if (cur->includeName=="entity" || cur->includeName=="component" )
+    {
+      entity=cur->includeName+" "+cur->type;
+      QCString rr=VhdlDocGen::parseForBinding(entity,arch);
+    }
+    else if (cur->includeName.isEmpty())
+    {
+      entity=cur->type;
+    }
+    ClassDef *classEntity=Doxygen::classSDict->find(entity);
+    inst=VhdlDocGen::getIndexWord(cur->args.data(),0);
+    ClassDef *cd=Doxygen::classSDict->find(inst);
+    ClassDef *ar=Doxygen::classSDict->find(cur->args);
+
+    if (cd==0 || classEntity==0 )
+      continue;
+
+    addInstance(classEntity,ar,cd,cur);
+
+  }
+}
+
+static void addInstance(ClassDef* classEntity, ClassDef* ar,
+                        ClassDef *cd , Entry *cur,ClassDef* /*archBind*/)
+{
+  if (classEntity==cd) return;
+
+  QCString bName=classEntity->name();
+  //printf("addInstance %s to %s\n", cd->name().data(), classEntity->name().data());
+  QCString n1=cur->type;
+
+  if (!cd->isBaseClass(classEntity, true, 0))
+  {
+    cd->insertBaseClass(classEntity,n1,Public,Normal,0);
+  }
+  else
+  {
+    VhdlDocGen::addBaseClass(cd,classEntity);
+  }
+
+  if (!VhdlDocGen::isSubClass(classEntity,cd,true,0))
+  {
+    classEntity->insertSubClass(cd,Public,Normal,0);
+  }
+
+  if (ar==0) return;
+
+  QCString uu=cur->name;
+  MemberDef *md=new MemberDef(
+      ar->getDefFileName(), cur->startLine,
+      cur->type,uu,uu, 0,
+      Public, Normal, cur->stat,Member,
+      MemberDef::Variable,
+      0,
+      0);
+
+  if (ar->getOutputFileBase()) 
+  {
+    TagInfo tg;
+    tg.anchor = 0;
+    tg.fileName = ar->getOutputFileBase();
+    tg.tagName = 0;
+    md->setTagInfo(&tg);
+  }
+
+  //fprintf(stderr,"\n%s%s%s\n",md->name().data(),cur->brief.data(),cur->doc.data());
+
+  md->setLanguage(SrcLangExt_VHDL);
+  md->setMemberSpecifiers(VhdlDocGen::INSTANTIATION);
+  md->setBriefDescription(cur->brief,cur->briefFile,cur->briefLine);
+  md->setBodySegment(cur->startLine,-1) ;
+  md->setDocumentation(cur->doc.data(),cur->docFile.data(),cur->docLine); 
+  FileDef *fd=ar->getFileDef();
+  md->setBodyDef(fd);
+  ar->insertMember(md);
+  //    printf("\nMemberreference [%p]",md);
+}
+
+
+void  VhdlDocGen::writeRecorUnit(QCString & largs,OutputList& ol ,const MemberDef *mdef)
+{
+  QStringList ql=QStringList::split("#",largs,FALSE);
+  uint len=ql.count();
+  for(uint i=0;i<len;i++)
+  {
+    QCString n=ql[i].utf8();
+    VhdlDocGen::formatString(n,ol,mdef);
+    if ((len-i)>1) ol.lineBreak();
+  }
+}
+
+
+void VhdlDocGen::writeRecUnitDocu(
+    const MemberDef *md,
+    OutputList& ol,
+    QCString largs
+    )
+{
+
+  QStringList ql=QStringList::split("#",largs,FALSE);
+  uint len=ql.count();
+  ol.startParameterList(TRUE);
+  bool first=TRUE;
+  for(uint i=0;i<len;i++)
+  {
+    QCString n=ql[i].utf8();
+    ol.startParameterType(first,"");
+    VhdlDocGen::formatString(n,ol,md);
+    if ((len-i)>1)
+    {
+      ol.endParameterName(FALSE,FALSE,FALSE);
+    }
+    else
+    {
+      ol.endParameterName(TRUE,FALSE,TRUE);
+    }
+
+    first=FALSE;
+  }
+}//#
+
+void VhdlDocGen::writeCodeFragment(OutputList& ol,int start, QCString & codeFragment,const MemberDef* mdef)
+{
+  QStringList qsl=QStringList::split("\n",codeFragment);
+  ol.startCodeFragment();
+  int len = qsl.count();
+  QCString lineNumber;
+  int j;
+  for (j=0;j<len;j++)
+  {
+    lineNumber.sprintf("%05d",start++);
+    lineNumber+=" ";
+    ol.startBold();
+    ol.docify(lineNumber.data());
+    ol.endBold();
+    ol.insertMemberAlign();
+    QCString q=qsl[j].utf8();
+    VhdlDocGen::writeFormatString(q,ol,mdef);
+    ol.docify("\n");
+  }
+  ol.endCodeFragment();
+}
+
+bool VhdlDocGen::isSubClass(ClassDef* cd,ClassDef *scd, bool followInstances,int level)
+{
+  bool found=FALSE;
+  //printf("isBaseClass(cd=%s) looking for %s\n",name().data(),bcd->name().data());
+  if (level>255)
+  {
+    err("Possible recursive class relation while inside %s and looking for %s\n",qPrint(cd->name()),qPrint(scd->name()));
+    abort();
+    return FALSE;
+  }
+
+  if (cd->subClasses())
+  {
+    // Beware: trying to optimise the iterator away using ->first() & ->next()
+    // causes bug 625531
+    BaseClassListIterator bcli(*cd->subClasses());
+    for ( ; bcli.current() && !found ; ++bcli)
+    {
+      ClassDef *ccd=bcli.current()->classDef;
+      if (!followInstances && ccd->templateMaster()) ccd=ccd->templateMaster();
+      //printf("isSubClass() subclass %s\n",ccd->name().data());
+      if (ccd==scd)
+      {
+        found=TRUE;
+      }
+      else 
+      {
+        if (level <256)
+        {
+          found=ccd->isBaseClass(scd,followInstances,level+1);
+        }
+      }
+    }
+  }
+  return found;
+}
+
+void VhdlDocGen::addBaseClass(ClassDef* cd,ClassDef *ent)
+{
+  if (cd->baseClasses())
+  {
+    BaseClassListIterator bcli(*cd->baseClasses());
+    for ( ; bcli.current()  ; ++bcli)
+    {
+      ClassDef *ccd=bcli.current()->classDef;
+      if (ccd==ent) 
+      {
+        QCString n = bcli.current()->usedName;
+        int i = n.find('(');
+        if(i<0)
+        {
+          bcli.current()->usedName.append("(2)");
+          return;
+        }
+        static QRegExp reg("[0-9]+");
+        QCString s=n.left(i);
+        QCString r=n.right(n.length()-i);
+        QCString t=r;
+        VhdlDocGen::deleteAllChars(r,')');
+        VhdlDocGen::deleteAllChars(r,'(');
+        r.setNum(r.toInt()+1);
+        t.replace(reg,r.data());
+        s.append(t.data());
+        bcli.current()->usedName=s;
+        bcli.current()->templSpecifiers=t;
+      }
+    }
+  }
+}
+
+
+
Index: src/filedef.cpp
===================================================================
--- src/filedef.cpp	(Revision 818)
+++ src/filedef.cpp	(Arbeitskopie)
@@ -37,6 +37,7 @@
 #include "debug.h"
 #include "layout.h"
 #include "entry.h"
+#include "verilogdocgen.h"
 
 //---------------------------------------------------------------------------
 
@@ -922,7 +923,7 @@
       break;
     case MemberDef::Define:       
       addMemberToList(MemberList::decDefineMembers,md);
-      addMemberToList(MemberList::docDefineMembers,md);
+  //    addMemberToList(MemberList::docDefineMembers,md);
       break;
     default:
        err("FileDef::insertMembers(): "
@@ -1622,14 +1623,18 @@
 void FileDef::writeMemberDeclarations(OutputList &ol,MemberList::ListType lt,const QCString &title)
 {
   static bool optVhdl = Config_getBool("OPTIMIZE_OUTPUT_VHDL");
+      static bool optVerilog = Config_getBool("OPTIMIZE_OUTPUT_VERILOG");
+
   MemberList * ml = getMemberList(lt);
   if (ml) 
   {
-    if (optVhdl) // use specific declarations function
+   if (optVhdl) // use specific declarations function
     {
-
-      VhdlDocGen::writeVhdlDeclarations(ml,ol,0,0,this,0);
-    }
+        if(optVerilog)
+       VerilogDocGen::writeVerilogDeclarations(ml,ol,0,0,this);
+         else 
+       VhdlDocGen::writeVhdlDeclarations(ml,ol,0,0,this,0);
+   }
     else
     {
       ml->writeDeclarations(ol,0,0,this,0,title,0);
Index: src/image.cpp
===================================================================
--- src/image.cpp	(Revision 818)
+++ src/image.cpp	(Arbeitskopie)
@@ -491,18 +491,21 @@
 
 ColoredImage::ColoredImage(int width,int height,
            const uchar *greyLevels,const uchar *alphaLevels,
-           int saturation,int hue,int gamma)
+           int saturation,int hue,int gamma,unsigned int* icon)
 {
   m_hasAlpha = alphaLevels!=0;
   m_width    = width;
   m_height   = height;
   m_data     = (uchar*)malloc(width*height*4);
   int i;
+ bool ic=(icon!=0); 
   for (i=0;i<width*height;i++)
   {
     uchar r,g,b,a;
     double red,green,blue;
-    hsl2rgb(hue/360.0,                            // hue
+	if(!ic)
+	{   
+	hsl2rgb(hue/360.0,                            // hue
             saturation/255.0,                     // saturation
             pow(greyLevels[i]/255.0,gamma/100.0), // luma (gamma corrected)
             &red,&green,&blue);
@@ -510,13 +513,29 @@
     g = (int)(green*255.0);
     b = (int)(blue *255.0);
     a = alphaLevels ? alphaLevels[i] : 255;
-    m_data[i*4+0]=r;
+	
+	m_data[i*4+0]=r;
     m_data[i*4+1]=g;
     m_data[i*4+2]=b;
     m_data[i*4+3]=a;
-  }
+	}
+	else
+	{
+      unsigned int val=icon[i];
+    int r1,g1,b1;
+    b1=(val & 0xff);   
+	g1=(val >>8) & 0xff;
+	r1=val>>16;
+	m_data[i*4+0]=b1;
+    m_data[i*4+1]=g1;
+    m_data[i*4+2]=r1;
+    m_data[i*4+3]=255;
+	}
+  
+  }//for
 }
 
+
 ColoredImage::~ColoredImage()
 {
   free(m_data);
Index: src/doxygen.cpp
===================================================================
--- src/doxygen.cpp	(Revision 818)
+++ src/doxygen.cpp	(Arbeitskopie)
@@ -83,6 +83,8 @@
 #include "filestorage.h"
 #include "markdown.h"
 #include "arguments.h"
+#include "verilogscanner.h"
+#include "preVerilog.h"
 
 #include "layout.h"
 
@@ -8816,8 +8818,16 @@
     {
       BufStr inBuf(fi.size()+4096);
       msg("Preprocessing %s...\n",s->data());
+      if(Config_getBool("OPTIMIZE_OUTPUT_VERILOG")) 
+	 {
+	//   readInputFile(fileName,preBuf);
+	   preprocessVerilogFile(fileName,preBuf,0,-1);
+	 }
+	 else 
+	 {
       readInputFile(fileName,inBuf);
       preprocessFile(fileName,inBuf,preBuf);
+     }
     }
     else // no preprocessing
     {
@@ -9359,6 +9369,7 @@
   Doxygen::parserManager->registerParser("dbusxml", new DBusXMLScanner);
   Doxygen::parserManager->registerParser("tcl",     new TclLanguageScanner);
   Doxygen::parserManager->registerParser("md",      new MarkdownFileParser);
+  Doxygen::parserManager->registerParser("v", new VerilogScanner);
 
   // register any additional parsers here...
 
@@ -9366,6 +9377,7 @@
   initClassMemberIndices();
   initNamespaceMemberIndices();
   initFileMemberIndices();
+  initVerilogPreprocessor();
 
   Doxygen::symbolMap     = new QDict<DefinitionIntf>(1000);
   Doxygen::inputNameList = new FileNameList;
@@ -9418,6 +9430,8 @@
   delete Doxygen::xrefLists;
   delete Doxygen::parserManager;
   cleanUpPreprocessor();
+   cleanUpVerilogPreprocessor();
+
   delete theTranslator;
   delete g_outputList;
   Mappers::freeMappers();
@@ -10530,6 +10544,9 @@
 
   msg("Adding members to index pages...\n");
   addMembersToIndex();
+
+   if (Config_getBool("OPTIMIZE_OUTPUT_VHDL") && Config_getBool("HAVE_DOT"))
+	   VhdlDocGen::writeOverview();
 }
 
 void generateOutput()
@@ -10695,6 +10712,9 @@
     writeGraphInfo(*g_outputList);
   }
 
+if(Config_getBool("OPTIMIZE_OUTPUT_VHDL") && Config_getBool("HAVE_DOT"))
+  VhdlDocGen::writeOverview(*g_outputList);
+
   msg("Generating directory documentation...\n");
   generateDirDocs(*g_outputList);
 
Index: src/config.l
===================================================================
--- src/config.l	(Revision 818)
+++ src/config.l	(Arbeitskopie)
@@ -1330,7 +1330,8 @@
     filePatternList.append("*.f90");
     filePatternList.append("*.f");
     filePatternList.append("*.for");
-    filePatternList.append("*.vhd");
+    filePatternList.append("*.v");
+	filePatternList.append("*.vhd");
     filePatternList.append("*.vhdl");
     filePatternList.append("*.tcl");
     filePatternList.append("*.md");
@@ -1354,7 +1355,8 @@
       filePatternList.append("*.PY");
       filePatternList.append("*.F90");
       filePatternList.append("*.F");
-      filePatternList.append("*.VHD");
+      filePatternList.append("*.V");
+	  filePatternList.append("*.VHD");
       filePatternList.append("*.VHDL");
       filePatternList.append("*.TCL");
       filePatternList.append("*.MD");
@@ -1467,6 +1469,15 @@
     annotationFromBrief.append("the");
   }
 
+  
+  
+// some default settings for verilog
+  if (Config_getBool("OPTIMIZE_OUTPUT_VERILOG"))
+  {
+   Config_getBool("OPTIMIZE_OUTPUT_VHDL")       = TRUE;
+  }
+
+  
   // some default settings for vhdl
   if (Config_getBool("OPTIMIZE_OUTPUT_VHDL") && 
       (Config_getBool("INLINE_INHERITED_MEMB") || 
@@ -1502,8 +1513,13 @@
     Config_getBool("EXTRACT_PRIVATE")       = TRUE;
     Config_getBool("ENABLE_PREPROCESSING")  = FALSE;
     Config_getBool("EXTRACT_PACKAGE")       = TRUE;
-  }                               
+  }  
 
+  if (Config_getBool("OPTIMIZE_OUTPUT_VERILOG"))
+  {
+   Config_getBool("ENABLE_PREPROCESSING")  = TRUE;
+  }
+  
 }
 
 void Config::init()
Index: src/util.h
===================================================================
--- src/util.h	(Revision 818)
+++ src/util.h	(Arbeitskopie)
@@ -388,6 +388,7 @@
   unsigned short height;
   unsigned char *content;
   unsigned char *alpha;
+   unsigned int * icon;
 };
 
 void writeColoredImgData(const char *dir,ColoredImgDataItem data[]);
Index: src/image.h
===================================================================
--- src/image.h	(Revision 818)
+++ src/image.h	(Arbeitskopie)
@@ -54,7 +54,7 @@
   public:
     ColoredImage(int width,int height,
            const uchar *greyLevels,const uchar *alphaLevels,
-           int saturation,int hue,int gamma);
+           int saturation,int hue,int gamma,unsigned int* icon=NULL);
    ~ColoredImage();
     bool save(const char *fileName);
     static void hsl2rgb(double h,double s,double l,
Index: src/classdef.cpp
===================================================================
--- src/classdef.cpp	(Revision 818)
+++ src/classdef.cpp	(Arbeitskopie)
@@ -39,7 +39,7 @@
 #include "vhdldocgen.h"
 #include "layout.h"
 #include "arguments.h"
-
+#include "verilogdocgen.h"
 //-----------------------------------------------------------------------------
 
 //static inline MemberList *createNewMemberList(MemberList::ListType lt)
@@ -302,7 +302,7 @@
   SrcLangExt lang = getLanguage();
   //static bool vhdlOpt = Config_getBool("OPTIMIZE_OUTPUT_VHDL");
   QCString n;
-  if (lang==SrcLangExt_VHDL)
+  if (lang==SrcLangExt_VHDL || lang==SrcLangExt_VERILOG)
   {
     n = VhdlDocGen::getClassName(this);
   }
@@ -391,9 +391,26 @@
                                    )
 {
   //printf("insertInternalMember(%s) isHidden()=%d\n",md->name().data(),md->isHidden());
-  if (md->isHidden()) return;
+ 
+  static bool optVerilog    = Config_getBool("OPTIMIZE_OUTPUT_VHDL");
+	
+if (md->isHidden()) return;
 
-  if (getLanguage()==SrcLangExt_VHDL)
+    if(optVerilog)
+	  {
+	  QCString tti=VhdlDocGen::trVhdlType(md->getMemberSpecifiers(),false);
+      //  VhdlDocGen::deleteAllChars(tti,' '); // Always Construct
+  
+        QStringList qsl=this->getList();
+        int i=qsl.findIndex(tti);
+        if(i<0)
+          this->addListType(tti);
+	  }
+
+
+
+
+  if (getLanguage()==SrcLangExt_VHDL || getLanguage()==SrcLangExt_VERILOG )
   {
     QCString title=VhdlDocGen::trVhdlType(md->getMemberSpecifiers(),FALSE);
     if (!m_impl->vhdlSummaryTitles.find(title))
@@ -1450,7 +1467,7 @@
   LayoutDocEntry *lde;
   bool first=TRUE;
   
-  if (getLanguage()!=SrcLangExt_VHDL)
+  if (getLanguage()!=SrcLangExt_VHDL  ||  getLanguage()!=SrcLangExt_VERILOG)
   {
     for (eli.toFirst();(lde=eli.current());++eli)
     {
@@ -1699,9 +1716,12 @@
       {
         ol.parseText(header);
       }
-      else if (lang==SrcLangExt_VHDL)
+      else if (lang==SrcLangExt_VHDL ||  lang==SrcLangExt_VERILOG)
       {
-        ol.parseText(VhdlDocGen::trVhdlType(VhdlDocGen::ARCHITECTURE,FALSE));
+	  if(lang==SrcLangExt_VERILOG)
+		 ol.parseText("Modules");
+	  else
+		 ol.parseText(VhdlDocGen::trVhdlType(VhdlDocGen::ARCHITECTURE,FALSE));
       }
       else
       {
@@ -1720,7 +1740,11 @@
         << "\">" << convertToXML(name()) << "</class>" << endl;
     }
     ol.startMemberItem(anchor(),FALSE);
-    QCString ctype = compoundTypeString();
+    QCString ctype;
+	if(lang==SrcLangExt_VERILOG)
+	   ctype=VhdlDocGen::getProtectionName((VhdlDocGen::VhdlClasses)protection());
+	else
+		ctype = compoundTypeString();
     QCString cname;
     if (localNames)
     {
@@ -1755,7 +1779,7 @@
       ol.docify(cname);
       ol.endBold();
     }
-    if (lang==SrcLangExt_VHDL) // now write the type
+    if (lang==SrcLangExt_VHDL || lang==SrcLangExt_VHDL) // now write the type
     {
       ol.writeString(" ");
       ol.insertMemberAlign();
@@ -2240,7 +2264,7 @@
         {
           ol.writeString("<span class=\"mlabel\">");
           QStrList sl;
-          if (lang==SrcLangExt_VHDL) 
+          if (lang==SrcLangExt_VHDL || lang==SrcLangExt_VERILOG) 
           {
             sl.append(VhdlDocGen::trVhdlType(md->getMemberSpecifiers())); //append vhdl type
           }
@@ -2251,7 +2275,8 @@
             if (Config_getBool("INLINE_INFO") && md->isInline())        
                                        sl.append("inline");
             if (md->isExplicit())      sl.append("explicit");
-            if (md->isMutable())       sl.append("mutable");
+            if (md->isMutable())    
+				sl.append("mutable");
             if (prot==Protected)       sl.append("protected");
             else if (prot==Private)    sl.append("private");
             else if (prot==Package)    sl.append("package");
@@ -3986,7 +4011,7 @@
   if (ml) 
   {
     //printf("%s: ClassDef::writeMemberDeclarations for %s\n",name().data(),ml->listTypeAsString().data());
-    if (getLanguage()==SrcLangExt_VHDL) // use specific declarations function
+    if (getLanguage()==SrcLangExt_VHDL || getLanguage()==SrcLangExt_VERILOG) // use specific declarations function
     {
       VhdlDocGen::writeVhdlDeclarations(ml,ol,0,this,0,0);
     }
Index: src/htmlgen.cpp
===================================================================
--- src/htmlgen.cpp	(Revision 818)
+++ src/htmlgen.cpp	(Arbeitskopie)
@@ -746,18 +746,18 @@
 
 static ColoredImgDataItem colored_tab_data[] =
 {
-  { "tab_a.png",    1, 36, tab_a_png, 0 },
-  { "tab_b.png",    1, 36, tab_b_png, 0 },
-  { "tab_h.png",    1, 36, tab_h_png, 0 },
-  { "tab_s.png",    1, 36, tab_s_png, 0 },
-  { "nav_h.png",    1, 12, header_png, 0 },
-  { "nav_f.png",    1, 56, func_header_png, 0 },
-  { "bc_s.png",     8, 32, bc_s_png, bc_s_a_png },
-  { "doxygen.png", 104,31, doxygen_png, doxygen_a_png },
-  { "closed.png",   9,  9, closed_png, closed_a_png },
-  { "open.png",     9,  9, open_png, open_a_png },
-  { "bdwn.png",     7,  8, bdwn_png, bdwn_a_png },
-  { 0, 0, 0, 0, 0 }
+  { "tab_a.png",    1, 36, tab_a_png, 0,0 },
+  { "tab_b.png",    1, 36, tab_b_png, 0 ,0},
+  { "tab_h.png",    1, 36, tab_h_png, 0 ,0},
+  { "tab_s.png",    1, 36, tab_s_png, 0 ,0},
+  { "nav_h.png",    1, 12, header_png, 0 ,0},
+  { "nav_f.png",    1, 56, func_header_png, 0,0 },
+  { "bc_s.png",     8, 32, bc_s_png, bc_s_a_png,0 },
+  { "doxygen.png", 104,31, doxygen_png, doxygen_a_png,0 },
+  { "closed.png",   9,  9, closed_png, closed_a_png ,0},
+  { "open.png",     9,  9, open_png, open_a_png,0 },
+  { "bdwn.png",     7,  8, bdwn_png, bdwn_a_png,0 },
+  { 0, 0, 0, 0, 0 ,0}
 };
 
 static img_data_item search_client_data[] =
Index: src/types.h
===================================================================
--- src/types.h	(Revision 818)
+++ src/types.h	(Arbeitskopie)
@@ -43,7 +43,8 @@
   SrcLangExt_VHDL     = 0x02000,
   SrcLangExt_XML      = 0x04000,
   SrcLangExt_Tcl      = 0x08000,
-  SrcLangExt_Markdown = 0x10000
+  SrcLangExt_Markdown = 0x10000,
+ SrcLangExt_VERILOG = 0x20000
 };
 
 struct Grouping 
Index: src/memberdef.cpp
===================================================================
--- src/memberdef.cpp	(Revision 818)
+++ src/memberdef.cpp	(Arbeitskopie)
@@ -42,7 +42,7 @@
 #include "vhdlscanner.h"
 #include "vhdldocgen.h"
 #include "arguments.h"
-
+#include "verilogdocgen.h"
 #define START_MARKER 0x4D454D5B // MEM[
 #define END_MARKER   0x4D454D5D // MEM]
 
@@ -762,6 +762,12 @@
   return FALSE;
 }
 
+
+QCString MemberDef::getDefinition() const
+{ 
+ return m_impl->def; 
+}
+
 void MemberDef::insertEnumField(MemberDef *md)
 {
   makeResident();
@@ -1807,7 +1813,7 @@
     //ol.startTypewriter();
     //ol.docify(" [");
     SrcLangExt lang = getLanguage();
-    bool optVhdl = lang==SrcLangExt_VHDL;
+    bool optVhdl = (lang==SrcLangExt_VHDL || lang==SrcLangExt_VERILOG); 
     if (optVhdl)
     {
       sl.append(VhdlDocGen::trTypeString(getMemberSpecifiers()));
@@ -2184,7 +2190,8 @@
 
   SrcLangExt lang = getLanguage();
   //printf("member=%s lang=%d\n",name().data(),lang);
-  bool optVhdl = lang==SrcLangExt_VHDL;
+   bool optVhdl =( lang==SrcLangExt_VHDL || lang==SrcLangExt_VERILOG);
+
   QCString sep = getLanguageSpecificSeparator(lang,TRUE);
 
   QCString scopeName = scName;
@@ -2393,7 +2400,7 @@
 
     if (optVhdl)
     {
-      VhdlDocGen::writeVHDLTypeDocumentation(this,container,ol);
+	    VhdlDocGen::writeVHDLTypeDocumentation(this,container,ol);
     }
     else
     {
Index: src/translator_en.h
===================================================================
--- src/translator_en.h	(Revision 818)
+++ src/translator_en.h	(Arbeitskopie)
@@ -463,7 +463,9 @@
      *  documentation blocks for defines
      */
     virtual QCString trDefineDocumentation()
-    { return "Macro Definition Documentation"; }
+    {
+		return "Macro Definition Documentation"; 
+	}
 
     /*! This is used in the documentation of a file/namespace before the list 
      *  of documentation blocks for function prototypes
Index: src/vhdlscanner.l
===================================================================
--- src/vhdlscanner.l	(Revision 818)
+++ src/vhdlscanner.l	(Arbeitskopie)
@@ -103,10 +103,11 @@
 //static int           g_inputLines=0;      //!<number of line in the code fragment
 //static bool          g_needsTermination;
 static	QMap<QCString, int> keyMap;
-
+static QList<Entry>  lineEntry;
+static bool  checkMultiComment(QCString& qcs,int line);
 static void handleCommentBlock(const QCString &doc,bool brief);
 static void mapLibPackage(const Entry* ce);
-static Entry* getEntryAtLine(const Entry* ce,int line);
+ static QList<Entry>* getEntryAtLine(const Entry* ce,int line);
 static bool addLibUseClause(const QCString &type);
 static Entry* oldEntry;
 static bool varr=FALSE;
@@ -554,18 +555,8 @@
     startComment=yyLineNr;
     g_lastCommentContext=YY_START;
   }
-
-  Entry* pTemp=getEntryAtLine(current_root,len);
-  if (pTemp)
-  { // found one line comment, add it to the entry on this line
-    pTemp->briefLine=yyLineNr;
-    pTemp->brief+=vhdlScanYYtext;
-    pTemp->briefFile=yyFileName;
-    pTemp->fileName = yyFileName;
- 	   
-    VhdlDocGen::prepareComment(pTemp->brief);
-  }
-  else 
+  
+   if(!checkMultiComment(qc,len))
   {
     strComment+=vhdlScanYYtext;
   }
@@ -629,25 +620,13 @@
 	  }
 
 	  //printf("--> handleCommentBlock line %d\n",yyLineNr);
-	  Entry* pTemp=getEntryAtLine(current_root,yyLineNr);
-
 	  if (!isEndCode && index==-1)
 	  {
 	    int j=qcs.find("--!");
 	    qcs=qcs.right(qcs.length()-3-j);
 
-	    if (pTemp)
+        if(!checkMultiComment(qcs,yyLineNr))
 	    {
-	      pTemp->briefLine=yyLineNr;
-	      pTemp->fileName = yyFileName;
- 	      qcs=qcs.stripWhiteSpace();
-	      pTemp->brief+=qcs;
-
-	      pTemp->briefFile=yyFileName;
-	      iDocLine=-1;
-	    }
-	    else
-	    {
 	      handleCommentBlock(qcs,TRUE);
 	    }
 	  }//endcode
@@ -985,26 +964,26 @@
   strComment.resize(0);
 }
 
-// returns the vhdl type parsed at line xxx
-static Entry* getEntryAtLine(const Entry* ce,int line)
-{
-  EntryListIterator eli(*ce->children());
-  Entry *found=0;
-  Entry *rt;
-  for (;(rt=eli.current());++eli)
-  {
-    if (rt->bodyLine==line)
-    {
-      found=rt;
-    } // if
-    if (!found) 
-    {
-      found=getEntryAtLine(rt,line);
-    }
-  }
-  return found;
-}// getEntryAtLine
+// returns the vhdl parsed types at line xxx
+
+QList<Entry>* getEntryAtLine(const Entry* ce,int line)
+{
+  EntryListIterator eli(*ce->children());
+  Entry *found=0;
+  Entry *rt;
+  for (;(rt=eli.current());++eli)
+  {
+    if (rt->bodyLine==line)
+    {
+		lineEntry.insert(0,rt);
+    } // if
+   
+    getEntryAtLine(rt,line);
+  }
+return &lineEntry;
+}
 
+
 // token index in vhdlparser.hpp 258..416
 int getParsedLine(int object)
 {
@@ -1022,3 +1001,25 @@
   handleCommentBlock(str_doc.doc,str_doc.brief);
   iDocLine=-1;
 }
+
+static bool  checkMultiComment(QCString& qcs,int line)
+{
+  QList<Entry> *pTemp=getEntryAtLine(current_root,line);
+
+ if (pTemp->isEmpty())  return false;
+  
+    int ii=pTemp->count();
+   qcs.stripPrefix("--!");
+    while(!pTemp->isEmpty()){
+    
+    Entry *e=(Entry*)pTemp->first();
+    e->briefLine=line;
+    e->brief+=qcs;
+    iDocLine=-1;
+    pTemp->removeFirst();
+    ii=pTemp->count();
+    }
+     return true; 
+ }
+ 
+ 
\ No newline at end of file
Index: winbuild/Doxygen.vcproj
===================================================================
--- winbuild/Doxygen.vcproj	(Revision 818)
+++ winbuild/Doxygen.vcproj	(Arbeitskopie)
@@ -123,9 +123,9 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="..\bin\Debug64"
-			IntermediateDirectory=".\Debug64"
+			Name="Release|Win32"
+			OutputDirectory="..\bin\Release"
+			IntermediateDirectory=".\Release"
 			ConfigurationType="1"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
@@ -141,6 +141,7 @@
 			/>
 			<Tool
 				Name="Lex"
+				CommandLine="flex [AllOptions] [AdditionalOptions] [inputs]"
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -150,23 +151,25 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TargetEnvironment="3"
-				TypeLibraryName=".\Debug64/Doxygen.tlb"
+				TypeLibraryName=".\Release/Doxygen.tlb"
 				HeaderFileName=""
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="/Zm200 /bigobj"
-				Optimization="0"
+				AdditionalOptions="/Zm200 "
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				OmitFramePointers="true"
+				WholeProgramOptimization="true"
 				AdditionalIncludeDirectories="..\src,..\qtools,..\libpng,..\libmd5,."
-				PreprocessorDefinitions="_CONSOLE;WIN32;_DEBUG; _CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;LIBICONV_STATIC;CHARSET_STATIC"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				PrecompiledHeaderFile=".\Debug64/Doxygen.pch"
-				AssemblerListingLocation=".\Debug64/"
-				ObjectFile=".\Debug64/"
-				ProgramDataBaseFileName=".\Debug64/"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE; _CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;LIBICONV_STATIC;CHARSET_STATIC"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/Doxygen.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
 				WarningLevel="3"
 				SuppressStartupBanner="true"
 				DebugInformationFormat="3"
@@ -176,7 +179,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="1033"
 			/>
 			<Tool
@@ -184,19 +187,18 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="qtools.lib ws2_32.lib iconv64.lib shell32.lib"
-				OutputFile="..\bin\Debug64\doxygen.exe"
-				LinkIncremental="2"
+				AdditionalOptions="/LTCG"
+				AdditionalDependencies="qtools.lib iconv.lib shell32.lib"
+				OutputFile="..\bin\Release\doxygen.exe"
+				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="Debug64"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile=".\Debug64/Doxygen.pdb"
+				AdditionalLibraryDirectories="Release"
+				ProgramDatabaseFile=".\Release/Doxygen.pdb"
 				SubSystem="1"
 				LargeAddressAware="2"
 				RandomizedBaseAddress="1"
 				DataExecutionPrevention="0"
-				TargetMachine="17"
+				TargetMachine="1"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -210,7 +212,7 @@
 			<Tool
 				Name="VCBscMakeTool"
 				SuppressStartupBanner="true"
-				OutputFile=".\Debug64/Doxygen.bsc"
+				OutputFile=".\Release/Doxygen.bsc"
 			/>
 			<Tool
 				Name="VCFxCopTool"
@@ -223,9 +225,9 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="..\bin\Release"
-			IntermediateDirectory=".\Release"
+			Name="Debug|x64"
+			OutputDirectory="..\bin\Debug64"
+			IntermediateDirectory=".\Debug64"
 			ConfigurationType="1"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
@@ -241,7 +243,6 @@
 			/>
 			<Tool
 				Name="Lex"
-				CommandLine="flex [AllOptions] [AdditionalOptions] [inputs]"
 			/>
 			<Tool
 				Name="VCXMLDataGeneratorTool"
@@ -251,25 +252,23 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/Doxygen.tlb"
+				TargetEnvironment="3"
+				TypeLibraryName=".\Debug64/Doxygen.tlb"
 				HeaderFileName=""
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="/Zm200 "
-				Optimization="2"
-				InlineFunctionExpansion="2"
-				OmitFramePointers="true"
-				WholeProgramOptimization="true"
+				AdditionalOptions="/Zm200 /bigobj"
+				Optimization="0"
 				AdditionalIncludeDirectories="..\src,..\qtools,..\libpng,..\libmd5,."
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE; _CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;LIBICONV_STATIC;CHARSET_STATIC"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile=".\Release/Doxygen.pch"
-				AssemblerListingLocation=".\Release/"
-				ObjectFile=".\Release/"
-				ProgramDataBaseFileName=".\Release/"
+				PreprocessorDefinitions="_CONSOLE;WIN32;_DEBUG; _CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;LIBICONV_STATIC;CHARSET_STATIC"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug64/Doxygen.pch"
+				AssemblerListingLocation=".\Debug64/"
+				ObjectFile=".\Debug64/"
+				ProgramDataBaseFileName=".\Debug64/"
 				WarningLevel="3"
 				SuppressStartupBanner="true"
 				DebugInformationFormat="3"
@@ -279,7 +278,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
+				PreprocessorDefinitions="_DEBUG"
 				Culture="1033"
 			/>
 			<Tool
@@ -287,18 +286,19 @@
 			/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalOptions="/LTCG"
-				AdditionalDependencies="qtools.lib iconv.lib shell32.lib"
-				OutputFile="..\bin\Release\doxygen.exe"
-				LinkIncremental="1"
+				AdditionalDependencies="qtools.lib ws2_32.lib iconv64.lib shell32.lib"
+				OutputFile="..\bin\Debug64\doxygen.exe"
+				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="Release"
-				ProgramDatabaseFile=".\Release/Doxygen.pdb"
+				AdditionalLibraryDirectories="Debug64"
+				GenerateManifest="false"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug64/Doxygen.pdb"
 				SubSystem="1"
 				LargeAddressAware="2"
 				RandomizedBaseAddress="1"
 				DataExecutionPrevention="0"
-				TargetMachine="1"
+				TargetMachine="17"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -312,7 +312,7 @@
 			<Tool
 				Name="VCBscMakeTool"
 				SuppressStartupBanner="true"
-				OutputFile=".\Release/Doxygen.bsc"
+				OutputFile=".\Debug64/Doxygen.bsc"
 			/>
 			<Tool
 				Name="VCFxCopTool"
@@ -455,7 +455,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -464,7 +464,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -499,7 +499,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -508,7 +508,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -539,7 +539,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -548,7 +548,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -579,7 +579,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -588,7 +588,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -622,7 +622,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -630,7 +630,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -670,7 +670,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -678,7 +678,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -710,19 +710,19 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
-						CommandLine="flex -PconfigYY [AllOptions] [AdditionalOptions] [inputs]"
+						CommandLine="flex  -PconfigYY [AllOptions] [AdditionalOptions] [inputs]"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
-						CommandLine="flex  -PconfigYY [AllOptions] [AdditionalOptions] [inputs]"
+						CommandLine="flex -PconfigYY [AllOptions] [AdditionalOptions] [inputs]"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
@@ -752,21 +752,21 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
-						CommandLine="flex -PcppExpYY -t $(InputDir)constexp.l &gt;$(InputDir)ce_lex.cpp"
+						CommandLine="flex  -PcppExpYY -t $(InputDir)constexp.l &gt;$(InputDir)ce_lex.cpp"
 						AdditionalDependencies="$(InputDir)constexp.l"
 						Output="$(InputDir)ce_lex.cpp"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
-						CommandLine="flex  -PcppExpYY -t $(InputDir)constexp.l &gt;$(InputDir)ce_lex.cpp"
+						CommandLine="flex -PcppExpYY -t $(InputDir)constexp.l &gt;$(InputDir)ce_lex.cpp"
 						AdditionalDependencies="$(InputDir)constexp.l"
 						Output="$(InputDir)ce_lex.cpp"
 					/>
@@ -796,7 +796,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCustomBuildTool"
@@ -806,7 +806,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCustomBuildTool"
@@ -839,7 +839,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -848,7 +848,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -883,7 +883,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -892,7 +892,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -926,7 +926,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -934,7 +934,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -966,7 +966,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -974,7 +974,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -1003,7 +1003,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1012,7 +1012,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1043,7 +1043,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1052,7 +1052,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1083,7 +1083,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1092,7 +1092,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1123,7 +1123,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1132,7 +1132,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1163,7 +1163,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1172,7 +1172,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1203,7 +1203,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1212,7 +1212,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1243,7 +1243,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1252,7 +1252,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1286,7 +1286,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -1294,7 +1294,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -1323,7 +1323,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1332,7 +1332,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1363,7 +1363,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1372,7 +1372,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1407,7 +1407,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1416,7 +1416,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1447,7 +1447,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1456,7 +1456,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1487,7 +1487,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1496,7 +1496,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1527,7 +1527,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1536,7 +1536,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1570,7 +1570,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -1578,7 +1578,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -1610,7 +1610,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -1618,7 +1618,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -1651,7 +1651,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1660,7 +1660,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1691,7 +1691,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1700,7 +1700,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1731,7 +1731,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1740,7 +1740,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1771,7 +1771,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1780,7 +1780,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1811,7 +1811,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1820,7 +1820,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1851,7 +1851,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1860,7 +1860,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1891,7 +1891,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1900,7 +1900,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1931,7 +1931,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1940,7 +1940,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1971,7 +1971,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -1980,7 +1980,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2011,7 +2011,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2020,7 +2020,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2051,7 +2051,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2060,7 +2060,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2091,7 +2091,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2100,7 +2100,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2139,7 +2139,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2148,7 +2148,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2179,7 +2179,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2188,7 +2188,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2219,7 +2219,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2228,7 +2228,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2259,7 +2259,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2268,7 +2268,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2307,7 +2307,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2316,7 +2316,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2347,7 +2347,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2356,7 +2356,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2387,7 +2387,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2396,7 +2396,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2427,7 +2427,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2436,7 +2436,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2467,7 +2467,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2476,7 +2476,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2507,7 +2507,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2516,7 +2516,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2551,7 +2551,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2560,7 +2560,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2595,7 +2595,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2604,7 +2604,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2635,7 +2635,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2644,7 +2644,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2675,7 +2675,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2684,7 +2684,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2715,7 +2715,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2724,7 +2724,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2766,6 +2766,14 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex  -PpreYY [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Debug|x64"
 					>
 					<Tool
@@ -2774,23 +2782,55 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Release|x64"
 					>
 					<Tool
 						Name="Lex"
 						CommandLine="flex  -PpreYY [AllOptions] [AdditionalOptions] [inputs]"
 					/>
 				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\src\preVerilog.l"
+				>
 				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -PpreYYVerilog [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex  -PpreYYVerilog [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -PpreYYVerilog [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Release|x64"
 					>
 					<Tool
 						Name="Lex"
-						CommandLine="flex  -PpreYY [AllOptions] [AdditionalOptions] [inputs]"
+						CommandLine="flex  -PpreYYVerilog [AllOptions] [AdditionalOptions] [inputs]"
 					/>
 				</FileConfiguration>
 			</File>
 			<File
+				RelativePath="..\src\preVerilog.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\src\pycode.cpp"
 				>
 			</File>
@@ -2806,7 +2846,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -2814,7 +2854,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -2846,7 +2886,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -2854,7 +2894,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -2883,7 +2923,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2892,7 +2932,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2923,7 +2963,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2932,7 +2972,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2963,7 +3003,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -2972,7 +3012,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3003,7 +3043,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3012,7 +3052,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3043,7 +3083,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3052,7 +3092,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3083,7 +3123,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3092,7 +3132,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3126,7 +3166,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -3134,7 +3174,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -3163,7 +3203,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3172,7 +3212,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3207,7 +3247,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3216,7 +3256,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3250,7 +3290,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -3258,7 +3298,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -3291,7 +3331,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3300,7 +3340,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3331,7 +3371,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3340,7 +3380,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3359,6 +3399,78 @@
 				</FileConfiguration>
 			</File>
 			<File
+				RelativePath="..\src\verilogdocgen.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\verilogparser.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\verilogparser.y"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description="Running bison on verilogparser.y"
+						CommandLine="runbison.bat $(InputDir)&#x0D;&#x0A;"
+						Outputs="$(InputDir)\..\src\verilogparser.cpp"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCustomBuildTool"
+						Description="Running bison on verilogparser.y"
+						CommandLine="runbison.bat $(InputDir)&#x0D;&#x0A;"
+						Outputs="$(InputDir)\..\src\verilogparser.cpp"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\src\verilogscanner.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\verilogscanner.l"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -i -PverilogScanYY [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -i -PverilogScanYY [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -i -PverilogScanYY [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="Lex"
+						CommandLine="flex -i -PverilogScanYY [AllOptions] [AdditionalOptions] [inputs]"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
 				RelativePath="..\src\version.cpp"
 				>
 				<FileConfiguration
@@ -3371,7 +3483,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3380,7 +3492,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3410,7 +3522,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -3418,7 +3530,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -3482,7 +3594,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="Lex"
@@ -3490,7 +3602,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="Lex"
@@ -3519,7 +3631,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3528,7 +3640,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3559,7 +3671,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3568,7 +3680,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -3928,6 +4040,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\src\preVerilog.h"
+				>
+			</File>
+			<File
 				RelativePath="..\src\printdocvisitor.h"
 				>
 			</File>
@@ -4197,7 +4313,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCustomBuildTool"
@@ -4207,7 +4323,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCustomBuildTool"
@@ -4232,6 +4348,18 @@
 				>
 			</File>
 			<File
+				RelativePath="..\src\verilogdocgen.h"
+				>
+			</File>
+			<File
+				RelativePath="..\src\verilogparser.hpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\verilogscanner.h"
+				>
+			</File>
+			<File
 				RelativePath="..\src\version.h"
 				>
 			</File>
Index: winbuild/runbison.bat
===================================================================
--- winbuild/runbison.bat	(Revision 818)
+++ winbuild/runbison.bat	(Arbeitskopie)
@@ -4,4 +4,5 @@
 
 bison -l -d -p vhdlScanYY %1\..\src\vhdlparser.y -o %1\..\src\vhdlparser.c
 del %1\..\src\vhdlparser.c
-bison -l -p vhdlScanYY %1\..\src\vhdlparser.y -o %1\..\src\vhdlparser.cpp
+bison -d -p vhdlScanYY %1\..\src\vhdlparser.y -o %1\..\src\vhdlparser.cpp
+bison -d -t -v %1\..\src\verilogparser.y -o %1\..\src\verilogparser.cpp
\ No newline at end of file
